// Micky1.05 begin
// Each VOBU presentation time is about 0.5s.

// [TIME control value]
// LVP08.01( title 11), >= 80000, or will be underflow
//                  The reason: if don't do time control, the time gap is about 2s. After multi-audio switching, it needs wait up 2s then go.
// Matrix(root menu),   10000~80000 is OK(highlight will display)
//                  The reason, every 2 NV will have highlight information, and the highlight start time will change
// The Spirit Of The Rain Forest , >= 15000
// TDL002(Title 6),   >= 40000, or audio willbe underflow (for MPEG audio)
#define EARLIER_TIME    80000L
//#define DEBUG_VOBU_TIME
// Micky1.05 end
//Micky0.65-909, modify HAL_CopyDRAM length into bytes unit.
// Micky0.87. for multi-angle title begin
// 1. Use smaller SkipGap and do reset before 2nd skip.
// 2. Add a _SearchFWDI function, as code overflow
// 3. CELL_Recover, for multi-angle, will base on last NV sector and skip 1s.
// define it, will use the PCI_NV_PCK_LBN info(updated by parser code)
// else will reference the info DSI_GI_NV_PCK_LBN(due to RISC will update PCI_NV_PCK_LBN)
// seems has problem when error concealment???
//#define REFERENCE_SECTOR_ID
// Micky0.87. for multi-angle title end

//////////////////////////////////////////////////////////////
// ***** Big Modification History Area *****
// LLY0.95, remove "REPEATAB_BY_CELL" related code.
// LLY2.17, don't include "winav.h" & "ctkav.h" since CELL module is protected module.
// LLY2.17, use __dwNVStart to keep NV start address, ie don't reference DS_NV_BUF_ADDR_ST directly
//          since the value maybe different base on DRAM configuration.
//          So, replace DS_NV_BUF_ADDR_ST w/ __dwNVStart


//#include    "winav.h"
#include    "setup.h"
#include    "cc.h"
#include    "cell.h"
#include    "nvcmd.h"
#include    "Srcfilter.h"
#include    "utl.h"
#include    "hal.h"
#include    "osd.h"
#include    "input.h"
#include    "comutl.h"
#include    "navigate.h"
// DVD_173Micky, include dvdinfo.h for __wSPRMs declare.
#include    "dvdinfo.h"
// DVD_273.2Micky, add special function to execute non-NOP command
#include    "infofilter.h"
#include    "chips.h"

// Micky2.35
extern void Service_420(void);

// If define it, the cell range will be played by linear.
// The range is start from 1st VOBU to last VOBU within the cell.
/// else, cell will be played VOBU by VOBU.
/// !!!this is for performance test only.!!! Default shoud be disabled.
//#define FORCE_LINEAR

// DVD_160Micky, fix "500 & China Blue"(summer night wind), can use number select(from 1.61)
// support number selection for invalid encode button info.(BaseOffset=17, SELBTN_Ns=0)
// define it, when no Selectable button, will force let all buttons can use number select.
// else, will fow the spec.
// will have problem when menu display number is not start from 1
#define SUPPORT_LOOSE_BUTTON_CONTROL

// DVD_170Micky, as navigate.c will update __bANL_Ns
// cell don't need serach angles number.
// can't be disabled if no problem occur.
//#define _DEBUG_ANGLES_NUMBER
//#define _DEBUG_BUTTON_STATE
//#define _DEBUG_CELL_RANGE
//#define _DEBUG_VOBU
//#define _DEBUG_STC
// LLY1.50, rename DUMP_INFORMATION w/ DUMP_CELL_INFO within cell module for debug cell information only
// And, it will be enabled automation if #define DUMP_INFORMATION
//#define DUMP_CELL_INFO
#ifdef  DUMP_INFORMATION
#undef DUMP_CELL_INFO
#define DUMP_CELL_INFO
#endif  // #ifdef DUMP_INFORMATION



// define it, can do debug for DSI reduce
// open _DEBUG_DIS only when needed.
///#define _DEBUG_DSI

//DVD_051Micky
// If mark CHECK_VOBU_E_PTM will not do VOBU_E_PTM check, problems:
//  (1) TDL-002 TT/CC 06/01 will have AC3->MPEG data skip problem
//  (2) The "Spirit of Rainforest" slides show will display too fast
// also check title LVP08.01 test disc 11. slide show audio smooth
// Micky0.68, enable check end time temporarily
#define CHECK_VOBU_E_PTM

// define it, CELL 1st NV fail, will do linear search.
//            2nd NV fail, will do VOBU skip.(By gap 10/30/60/120 seconds)
//            Finally will switch to linear play mode.
//            Once NV_INT is checked, switch back to CELL_NORMAL mode
// if not defined, will just hang at NV sector.
#ifdef  ERROR_CONCEAL
#define ENHANCE_CELL_ERROR_CONCEAL
#endif

//#define _CELL_INFO
#define MIN_VOBU    1          // 16 is valid

//Aron1.08-909, define the size of ring buffer to keep
//past NV's start/end presentation time and UOP field
#define PAST_NV_RING_BUFF_SIZE 10

BYTE    __bVOBUStill;    // flag indicate the VOBU still is on/off
BYTE    __bSTCRunning;//Micky2.80, review global variables init.=FALSE;

// Aron2.30, used to keep VOBU presentation time start.
DWORD   __dwVOBU_S_PTM;
// record the end presentation time of current VOBU.(By 90KHz/sec format)
DWORD   __dwVOBU_E_PTM;
// modify the time display information
//DWORD   __dw1stSCR;

// LLY2.17, use a variable to keep NV buffer start address
// Since, the address maybe different base on different DRAM configuration.
// So, replace DS_NV_BUF_ADDR_ST w/ __dwNVStart
DWORD   __dwNVStart;


#ifndef NO_DVD
// DVD_274Micky, add copyright. Don't remove it!!!!
BYTE    Copyright_CHEERTEK_INC_2002_CELL;

// DVD_160Micky
// reference VI3-66, once transferred to Action state, any transfer shall not allowed
// DVD_275Micky, share the same variable.
#define _bButtonState Copyright_CHEERTEK_INC_2002_CELL
///BYTE    _bButtonState;

// Micky2.80, review global variables init.
//DWORD   *pdwBuffer=NULL;
// Micky1.05 begin
// LLY1.05, remove this varible for code reduce since it can use constant value now.
//DWORD   __dwEARLIER_TIME = EARLIER_TIME;
BYTE    _Decide_VOBU_Control(void);
// Micky1.05 end
// should be assigned by CELL_Initial
DWORD   __dwCellFVOBUSA;    // physical start address of 1st VOBU in this cell
DWORD   __dwCellFILVUEA;
DWORD   __dwCellLVOBUSA;
DWORD   __dwCellLVOBUEA;    // physical end address of last VOBU in this cell
BYTE     __bSeamlessAngleChange;
BYTE     __bInterleaved;

// when debug reduce DSI, will read all DSI for comparison
#if !defined(REDUCE_DSI) || (defined(REDUCE_DSI) && defined(_DEBUG_DSI))
DSI   *pDSI;  // store DSI info.
#define cDSI    (*pDSI)
#endif

// LLY2.32, porting Micky's code for using time map table
// Micky07312006 begin, for TMAP
BYTE	_bUpdateSCR;
// Micky07312006 end ...


// for Scan back recursive protection
// Keep previous scan position, it will be updated by __dwVOBUSA during scan mode
// And, will be clear to 0xffffffff while VOBU_START & CELL_Initial()
DWORD   _dwPreScanPosition;//Micky2.80, review global variables init.=0xffffffff;

// this will be multi-angle change reference
DWORD    __dwCurrentVOBUSA; // current VOBU Start address
DWORD   __dwVOBUSA;       // it records the offset to the FVOBU
DWORD   __dwVOBUEA;       // it records the end offset of this VOBU
DWORD   __dwVOBUStart;      // it records the logical sector for VOBU start
DWORD   __dwVOBUEnd;        // it records the logical sector for VOBU end
DWORD   __dwILVUEnd;      // it records the logical sector for ILVU end
DWORD   __dwILVUEA;       // it records the end offset of this ILVU
DWORD   __dwNextILVUSA;     // it records the start address of next ILVU
//Aron1.15-909, it is not uesd by others, comment it!
//WORD    __wNextILVUSZ;    // it records the next ILVU sectors

BYTE    __bAngleChange;         // TRUE, indicate need do seamless angle change
// Micky2.31, remove __bAngle initial value
BYTE    __bAngle;//=1;             // Angle number, only referenced when angle is changed
BYTE    __bCellAction;   // status of current CELL action
DWORD   __dwVOBUSRI;

// [ Button information ]
BYTE    __bBTNBaseOffset;       // BTN offset
BYTE    __bBTNEndOffset;        // BTN offset
BYTE    __bSELBTN_Ns;           // number of selectable buttons
BYTE    __bBTN_Ns;              // number of total buttons
BYTE    __bDefaultHL_BTNN;      // default selection button number
BYTE    __bForceActiveBTNN;     // forced active button number
// LLY1.15, remove HLI start/end time variable, since it can reference PCI info directly
//DWORD   __dwHLStartTime;        // button highlight start time
//DWORD   __dwHLEndTime;          // buttom highlight end time
DWORD   __dwBTNSelEndTime;      // end of buttion selection time
// the __bNowBTNNumber is valid from 1~36
BYTE    __bNowBTNNumber;      // current selection BTNN

//Aron1.08-909, For DVD Forum NF250, the UOPs test will not pass since the NV
//issue. TT/CC: 07/14 press KEY_PAUSE can be permitted during time 2:18:xx ~ 2:19:xx
//==> Pause key should be prohibited during time 2:10 ~ 2:20.
//Therefore, I add one ring buffer to keep past NV's
//start/end presentation time and UOP field to get right UOP when do CELL_QueryUOP
PAST_NV_UOP _past_NV_UOPs[PAST_NV_RING_BUFF_SIZE];
WORD _wNV_UOPs_WP = 0; // write pointer of _past_NV_UOPs ring buffer

// System parameters
extern  DWORD       _dwFirst_VOBS;
// DVD_173Micky, remove __wSPRMs declare.
///extern  WORD        __wSPRMs [24];

// temporary buffer for DSI/PCI data access
// max. size used now 120(30*4)
// DVD_172r2, use __cBuffer[160].
///char    _cTempBuffer[200];

// when debug reduce DSI, will read all DSI
#if !defined(REDUCE_DSI) || (defined(REDUCE_DSI) && defined(_DEBUG_DSI))
char    _cDSIBuffer[110*4];
#endif

PCI_BTNIT   *_pBTNInfo;

// ** TCH0.451; 0-PS, 1-LB, 2-16:9, 3-4:3.
extern BYTE    __bSPST_Display_Mode;
extern BYTE    __bSPST_LB;
extern  DWORD   __dwTimeA, __dwTimeB;

// The variable is used to keep NV related information.
// bit [7:6], for same NV sector send count.
// the count will be cleared when 1) NV_INT got. 2) 2nd NV_INT fail after re-sending.
// bit [4], will be linear search NV sector
// bit [3:0], the NV sector state
BYTE    _bCheckNVData;

// the _bIndex is to be used as a temporarily variable within function
// and the function won't call other cell APIs(public or protected)
static  BYTE    _bIndex;
static BYTE    _bEnableTimeSearch;
static DWORD   _dwSearchTime;
// record the start time that sending NV sector.
DWORD   _dwTimeNV;

// LLY1.05, recode the time while issue SCAN CMD (remove from CC module)
DWORD   __dwTimeRef;

// [CELL Recover]
BYTE    _bNVRecover;    // 0, not doing NV skip
                        // 1~ MAX_SKIP_GAP1, doing NV skip.
                        // MAX_SKIP_GAP1+1, linear play mode.
extern BYTE        __bStillTime;   // record the Still Time (0: NONE, 0xFF: Infinite; Other: seconds.)
extern DWORD       __dwTimeStill;  // record Still starting SYSTEM Counter
extern C_PBI       __pbi_CELL;
//Scan forward      //Scan Backward
// 1sec=FWDI2=19     1sec=BWDI2=24
// 2sec=FWDI4=17     2sec=BWDI4=26
// 4sec=FWDI8=13     4sec=BWDI8=30
// 8sec=FWDI15=6     8sec=BWDI15=37
//10sec=FWDI20=5    10sec=BWDI20=38
//30sec=FWDI60=4    30sec=BWDI60=39
//60sec=FWDI120=3   60sec=BWDI120=40
//120sec=FWDI240=2  120sec=BWDI240=41
//!!! can't use FWDI1 as it's possible the current VOBU(0.4~1)
BYTE code bFWDI[8]={19, 17, 13, 6, 5, 4, 3, 2};
BYTE code bBWDI[8]={24, 26, 30, 37, 39, 39, 40, 41};

// when force active button is time out, must set the flag,
// so that PGC will execute the button command
BYTE    __bCellActiveBTN;


#define SKIP_NONE   0
#define SKIP_PREPARE    1
#define SKIP_NOW        2
// for non-seamless angle change
BYTE    __bSkip1Sec;//Micky2.80, review global variables init=SKIP_NONE;

// DVD_170Micky, as navigate.c will update __bANL_Ns
// cell don't need serach angles number.
#ifdef  _DEBUG_ANGLES_NUMBER
static  BYTE    _bAngleCheck;
#endif

#endif  //#ifndef NO_DVD

// DVD_170Micky, unused anfle search code.
//static BYTE    _bSearchAngle;

// DVD_103Micky, record last played VOBUSA that has video data
// for resume to play w/ video data
DWORD   __dwCellVideo_VOBUSA;

BYTE    __bCellState;   // CELL_SEARCH_1ST_NV, do linear serach NV
                        // CELL_LINEAR, linear play the remain cell
                        // CELL_NORMAL, normal play NV+VOBU
                        // CELL_SKIP_VOBU, NV fail, skip VOBU.
#ifdef  ENHANCE_CELL_ERROR_CONCEAL
DWORD   _dwLastVOBUSA;
#endif

// DVD_161Micky, add a function to update cell range
void    _UpdateCellInfo(void);
// DVD_171Micky
#define CELL_MAX_SKIP_GAP   4
// FWDI 20/60/120/240, means 10/30/60/120 seconds
// Micky0.87, use smaller skip range, then big range
//BYTE code _bSkipGap[CELL_MAX_SKIP_GAP]= {5, 4, 3, 2};
//BYTE code _bSkipTime[CELL_MAX_SKIP_GAP]= {10, 30, 60, 120};
BYTE code _bSkipGap[CELL_MAX_SKIP_GAP]= {19, 17, 5, 4};
BYTE code _bSkipTime[CELL_MAX_SKIP_GAP]= {1, 2, 10, 30};

// DVD_171Micky, don't show angle mark when angle change UOP is not allowed
BYTE    _bAngleCtrlCheck;
// DVD_273.2, for encrpyted DVD begin
// clear the auto scan next cell's command.
extern BYTE    __bAutoScans;
// DVD_273.2, for encrpyted DVD end

//Ming0.80, use PCI and DSI directly.
// Do not need _UpdateBTNInfo().
//// Micky2.31, reduce codes, add API _UpdateBTNInfo()
//void    _UpdateBTNInfo(BYTE bBTN_Number);

// Micky0.87, code reduce.
DWORD   _SearchFWDI(BYTE bIndex);
// Micky1.02, fix time search forward, will hang at below loop(after total reset)
// video wait pic size to become positive value
// but cell wait STC to reach VOBU_E_PTM to send next VOBU
// need investigate why can't detect 1st video pts
// must force to update STC before play dedicated VOBU.
// can remove the force reset STC when the problem is cleared
BYTE    _bForceResetSTC;

// LLY1.06, add a flag to keep if isse force freeze STC control
BYTE    _bForceFreezeSTC=FALSE;

#ifdef CELL_FORCE_LINEAR_PLAY_TEST
BYTE _bLinearNPFFlags;
void _SwitchLinearPlayAndNVPlay(BYTE bForce2NVPlay);
#endif // CELL_FORCE_LINEAR_PLAY_TEST

// LLY2.32, porting Micky's code to fix some DVD tile root menu can't play end issue
// for Harry Potter & Alexander root menu can't play end--begin
void	CELL_LinearPlay(void);
// for Harry Potter & Alexander root menu can't play end--end


//Ming0.80, use PCI and DSI directly.
volatile DSI *_pDSI;
volatile PCI *_pPCI;

//#include "ctkav.h"
#include "disp.h"
#include "subpict.h"
#include "comdec.h"
#include "parser.h"
volatile PHLI    __pHLIBuffer;

BYTE    __bGroupOffset = 0;
void _CELL_SetBTNGroup(BYTE bGroupID, BYTE bGroups)
{
    __bGroupOffset = bGroupID*(36/bGroups);
}
//**********************************************************************
//  Function    : CELL_CellInitial
//  Description : When change a new cell(The cell must match the Angle),
//              : must call this function, and pass the cell play back info.
//  Parameters  : pC_PBC, a structure of C_PBI(ref. VI4-100)
//**********************************************************************
BYTE CELL_CellInitial(C_PBI *pC_PBI)
{
#ifndef NO_DVD

extern  DWORD       _dwFirst_VOBS;      // ** TCH0.25;

#define cC_PBI  (*pC_PBI)

    cC_PBI=*(pC_PBI);

    // first sector address for first VOBU of the CELL
    __dwCellFVOBUSA= cC_PBI.C_FVOBU_SA;
    // end sector address for first ILVU of the CELL
    __dwCellFILVUEA= cC_PBI.C_FILVU_EA;
    // start sector address for last VOBU of the CELL
    __dwCellLVOBUSA= cC_PBI.C_LVOBU_SA;
    // end sector address for last VOBU of the CELL
    __dwCellLVOBUEA= cC_PBI.C_LVOBU_EA;

#ifdef  USE_LITTLE_ENDIAN
    COMUTL_SwapDWORD ( &__dwCellFVOBUSA );
    COMUTL_SwapDWORD ( &__dwCellFILVUEA );
    COMUTL_SwapDWORD ( &__dwCellLVOBUSA );
    COMUTL_SwapDWORD ( &__dwCellLVOBUEA );
#endif  // #ifdef USE_LITTLE_ENDIAN

    // Get cell playback mode, if 1 means VOBU Still
    __bVOBUStill=(cC_PBI.C_CAT[1] & 0x40) >> 6;

    __dwCellFVOBUSA+= _dwFirst_VOBS;
    __dwCellFILVUEA+= _dwFirst_VOBS;
    __dwCellLVOBUSA+= _dwFirst_VOBS;
    __dwCellLVOBUEA+= _dwFirst_VOBS;

#ifdef  DUMP_CELL_INFO
    DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nCellFVOBUSA=%lu, CellLVOBUEA=%lu", __dwCellFVOBUSA, __dwCellLVOBUEA);
#endif  // #ifdef DUMP_CELL_INFO



    // LLY1.06, un-freeze the STC value while each CELL begin & previous STC is force freezed
    // Otherwise, STC value maybe freeze @ VOBU_STILL
    // But, nobody to un-freeze it except PLAY/ PAUSE key to release VOBU still
    // ex. VOBU_STILL --> GoTime/ NEXT/ PREV/ Navigate Time out and go next PGC
    if(_bForceFreezeSTC==TRUE)
    {
        _bForceFreezeSTC=FALSE;
        DISP_STCFreeze(0x0, DISP_UNFREEZE_STC);
        DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "Un-freeze STC\n");
    }

    // flag indicate that the CELL is allocated in interleaved block or not
    // bit 26
    __bInterleaved=(cC_PBI.C_CAT[0]& 0x04) >> 2;

    // flag indicate that the CELL seamless angle change flag
    // bit 24
    __bSeamlessAngleChange=(cC_PBI.C_CAT[0]& 0x01);

    __dwVOBUSA=0;
    __dwVOBUSRI=0;
    __dwCurrentVOBUSA=0;
    //Aron1.15-909, it is not uesd by others, comment it!
    //__wNextILVUSZ=0;
    __dwNextILVUSA=0;
    _bNVRecover=0;
    __bAngleChange=FALSE;

    //DVD_050aMicky
    //Use valid PCI/DSI data
    // in title "The title DVD extravaganza, dts test", surround test
    // has angle information recorded in NSML_AGL field
    // check the C_PBI C_CAT cell block type(VI4-100)
    // 1st cell in block and is angle block, then need check number of angles
// DVD_170Micky, as navigate.c will update __bANL_Ns
// cell don't need serach angles number.
#ifdef  _DEBUG_ANGLES_NUMBER
    _bAngleCheck=(cC_PBI.C_CAT[0]& 0x30) >>4;

    if (_bAngleCheck==0x01) // angle block
    {
    }
    else    // not angle block
    {
        // prev. cell may have angle information, must clear
        __bAngle=1;
        __bAGL_Ns=0;    // total angle numbers
        __bAGLN= NULL;  // current angle number
        OSD_OUTPUT_MACRO ( MSG_ANGLE_CTL, 0, 0);
    }
#else   // #ifndef  _DEBUG_ANGLES_NUMBER
    // angle block, need send OSD message.

    // Micky2.78, fix "angle---" display on Ritek menu
    // PBC on-> Play 6/1-> press Next twice->Angle--- display at Golden Man menu
    // must give _bAngleCtrlCheck an initial value 0.
    // assume not a angle block, don't need check angle display
    _bAngleCtrlCheck = 0;
    if ( ((cC_PBI.C_CAT[0]& 0x30) >>4)==0x01 )
    {
        // DVD_171Micky, check angle control for cell
        // only after one NV_INT is got, query angle change UOP
        // if allow angle change, then will display angle information.
        // Micky2.78, fix "angle---" display on Ritek menu
        // Only __bAGLN is non-zero need check angle display
        if ( __bAGLN )
            _bAngleCtrlCheck=1;
    }
    // for non-angle block, should no angle information, done by pgc.
#endif  // #ifndef  _DEBUG_ANGLES_NUMBER

    // DVD_171-3Micky, fix Tarzan , select "The Music of Tarzan" 1~5 items ,
    // it always play DVD menu.
    // It will play 37/2(cell play) -> then CallSS(+RSM),
    // navigate will do SPRMs[8]=NowNTNNumber<<10(RSM_Control(STATUS_SAVE)
    // but CellInitial will clear __bNowBTNNumber as 0, cause SPRMs[8]=0.
    // Since _bButtonState has top priority, no need to clear __bNowBTNNumber.
///    __bNowBTNNumber=0;

    __bCellAction=VOBU_START;
    _bCheckNVData=CELL_NV_NONE;

    // normal state, not doing any time search
    _bEnableTimeSearch=CELL_TIMESEARCH_NONE;

    //Ming0.80, use PCI and DSI directly.
    _pDSI = (volatile DSI*)DSI_BASE;
    _pPCI = (volatile PCI*)PCI_BASE;

    // support SCB from chapter end
    if (__bModeCmd==KEY_SCB)
    {
        // Using last VOBU address - 1st VOBU address to get __dwVOBUSA (the offset to the 1st VOBU)
        // ie. it used to support SCB from chapter end.
        __dwVOBUSA=__dwCellLVOBUSA-__dwCellFVOBUSA;
        __dwCurrentVOBUSA=__dwVOBUSA;

        // LLY2.38, enable update SCR flag to find 1stSCR while SCB mode crossing cell
        // And, remove old procedure: dump 1st NV sector within the cell.
        _bUpdateSCR=TRUE;
#if 0
        // DVD_171-2Micky, only read 1st NV for __dw1stSCR when SCB mode.
        __dwTimeBegin = __dwCellFVOBUSA ;
        __dwTimeEnd = __dwCellFVOBUSA ;
        // LLY2.35, give start and end time for UTL_PlayFromTime() since the API is updated
        UTL_PlayFromTime (__dwCellFVOBUSA, __dwTimeEnd) ;

        // Ming0.68-909, Must wait for NV to update the SCR.
        if(!_WaitParserEventNV(COUNT_500_MSEC))
        {
            __dw1stSCR = 0;
        }
        else
        {
        	//Micky0.68, get SCR from DSI, and use PCI/ DSI information directly
            //__dw1stSCR = _pDSI->DSI_GI.NVPCK_SCR;
        	__dw1stSCR =COMUTL_ReadBufferDWORD ( (char *)&(_pDSI->DSI_GI.NVPCK_SCR), 0);

        }
#endif  // #if 0
    }
    // LLY2.38, must turn-off update SCR flag while no SCB mode.
    else
    {
        _bUpdateSCR = FALSE;
    }

    __bSTCRunning=FALSE;
    __bSkip1Sec = SKIP_NONE;

    //CLEAR highlight
    HAL_ControlHighlight(HAL_HLI_ACTION_TURNOFF, 0);

    // clear the highlight/button info.
    __bBTN_Ns=0;
    __bSELBTN_Ns=0;
    __bForceActiveBTNN=0;
    __bCellActiveBTN=FALSE;

    // DVD_160Micky
    // reference VI3-66, once transferred to Action state, any transfer shall not allowed
    _bButtonState = CELL_BUTTON_NONE;

    // clear CELL still state
    __bStillTime=0;

    //Aron2.37, clear start & end of presentation time here.
    __dwVOBU_S_PTM = 0;
    __dwVOBU_E_PTM = 0;


    __bCellState=CELL_SEARCH_1ST_NV;


    // Micky2.80, review global variables init.
    _dwPreScanPosition=0xffffffff;

    // Micky1.02, fix time search forward, will hang at below loop(after total reset)
    // video wait pic size to become positive value
    // but cell wait STC to reach VOBU_E_PTM to send next VOBU
    // need investigate why can't detect 1st video pts
    // must force to update STC before play dedicated VOBU.
    // can remove the force reset STC when the problem is cleared
    _bForceResetSTC = 0;

    // LLY2.32, porting Micky's code for using time map table
    // Micky07312006 begin, for TMAP
    // LLY2.38, remove it since it will be done earily within CELL_CellInitial()
 	//_bUpdateSCR = FALSE;
    // Micky07312006 end ...


#ifdef CELL_FORCE_LINEAR_PLAY_TEST
    _bLinearNPFFlags = CELL_LINEAR_NPF_OK;
    DVD_ParseInfo ( DVD_TT_PB_TY, &__dwTemp, __bTitle );
    if((__dwTemp & 0x40) ||     // Not an One_Sequential_PGC title
       __bVOBUStill ||
       __bInterleaved ||
       (__bAGL_Ns > 1) ||
       (__bDomain != TT_DOM))
    {
        _bLinearNPFFlags = 0;
    }
#endif // #ifdef CELL_FORCE_LINEAR_PLAY_TEST

    // LLY2.32, must always disable NV_PAUSE command while playback a new cell range
    //Ming0.80, If run the previous cell in linear mode. The NV pause is opened.
    //          Must close it before playing the next cell.
    PARSER_ActionFilter(0, PARSER_ENABLE_NV_PAUSE, FALSE);


#endif  //#ifndef NO_DVD

    // Suppose the setting should be ready before playing CELL
    // if bEnableRunning=TRUE, must call SrcFilter_Stop to set it as FALSE.
    // or SrcFilter_ReadSectors won't do the action.
    // put at UTL_PlayFromTime???
    // wyc2.53-909P,
    SrcFilter_Stop(__dwSFStreamID);

	// set NV buffer address
    // Chuan0.85, Use DS_NV_BUF_ADDR_ST/DS_NV_BUF_ADDR_END
    // LLY2.17, remove it since it will be done @ HAL_SetDiscType()
    //PARSER_SetOutBufferAddress(PARSER_ES_NV, DS_NV_BUF_ADDR_ST, DS_NV_BUF_ADDR_END);

    // enable parsing NV
    PARSER_ActionFilter(0, PARSER_ENABLE_NV, TRUE);


    return TRUE;
}

//DVD_036GOTOTIME begin
BYTE    CELL_TimeSearch(BYTE bFunction, DWORD dwTime)
{
#ifndef NO_DVD
    switch(bFunction)
    {
        case    CELL_TIME_FREEZE:
                // DVD_171-2Micky, re-define the parameter for _bEnableTimeSearch
                // force CELL to stay at end of VOBU
                _bEnableTimeSearch=CELL_TIMESEARCH_FREEZE;
                break;
        case    CELL_TIME_PLAY:
#ifdef  DUMP_CELL_INFO
                DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nTimeSearch, __bCellState=0x%hx, __dwVOBUSA=0x%lx", __bCellState, __dwVOBUSA);
#endif  //#ifdef  DUMP_CELL_INFO

                // DVD_171-2Micky, re-define the parameter for _bEnableTimeSearch
                // will search VOBU time till specified time is found
                _bEnableTimeSearch=CELL_TIMESEARCH_TIME;
                _dwSearchTime=dwTime;

                // LLY2.32, porting Micky's code for using time map table
                // Micky07312006 begin, for TMAP
				// will do TMAP search first
#ifdef	SUPPORT_TMAP_SEARCH
				__bCellAction = TIME_SEARCH;
#endif	//#ifdef	SUPPORT_TMAP_SEARCH
                // Micky07312006 end ...
                break;

        case    CELL_TIME_VOBU:
                // directly play from specified VOBUSA.
                __dwVOBUSA=dwTime;
                // DVD_171-2Micky, when time search from specified VOBUSA
                // and not from 1st VOBU, will force to read 1st NV for __dw1stSCR value
                // (<=170, was done by CellInitial whenever it's called)
                // Can test GoldenEye-> menu->play(action is resume), display time.
                // Dinosaur title is same.
                if (__dwVOBUSA != 0)
                {
                    // LLY2.55, enable update SCR flag to find 1stSCR while SCB mode crossing cell
                    // And, remove old procedure: dump 1st NV sector within the cell.
                    _bUpdateSCR=TRUE;

#if 0
                    __dwTimeBegin = __dwCellFVOBUSA ;
                    __dwTimeEnd = __dwCellFVOBUSA ;
                    // LLY2.35, give start and end time for UTL_PlayFromTime() since the API is updated
                    UTL_PlayFromTime (__dwCellFVOBUSA, __dwTimeEnd) ;

                    // Ming0.68-909, Must wait for NV to update the SCR.
                    // Micky1.01, Fix "The Man with the golden gun"-> 1/2-> root menu-> play(resume)
                    // the display time will show chapter begin then real resume time.
                    // must enlarge the time out to 2s.
                    if(!_WaitParserEventNV(COUNT_2_SEC) ) //COUNT_500_MSEC))
                    {
                        __dw1stSCR = 0;
                        // LLY1.01, clear break here, since following flow must be done continue.
                        //break;
                    }
                    else
                    {
    			    	//Micky0.68, get SCR from DSI
        	            //HAL_ReadInfo(HAL_INFO_SCR, &__dw1stSCR);
                        //Ming0.80, use PCI and DSI directly.
                        //HAL_CopyDRAM (DSI_GI_BASE, (DWORD)&__dw1stSCR, 4);
                        __dw1stSCR = COMUTL_ReadBufferDWORD ( (char *)&(_pDSI->DSI_GI.NVPCK_SCR), 0);//_pDSI->DSI_GI.NVPCK_SCR;
                    }
#endif  // #if 0

                    // Micky1.00-2, Fix "Chocolate" Menu-> 2nd highlight-> play film(resume) can't play.
                    // The DPS will wait STC to reach the resumed position's STC then continue decoding
                    // need let video update 1st PTS from parser(video pts)
                    // after RISC update, it will set the value as 0x11xxxx.
                    // COMMAND_NEWSTC will auto set DRAM_STC_UPDTAE as 0 too.
                    // Micky1.02, fix time search forward, will hang at below loop(after total reset)
                    // video wait pic size to become positive value
                    // but cell wait STC to reach VOBU_E_PTM to send next VOBU
                    // need investigate why can't detect 1st video pts
                    // must force to update STC before play dedicated VOBU.
                    // can remove the force reset STC when the problem is cleared
                    HAL_ControlAVSync (HAL_AVSYNC_VIDEOMASTER, 1); // ** TCH1.00-908;      Enable Video Master Mode.
                    _bForceResetSTC = TRUE;
                    // Micky1.01, fix resume play, sometimes will play from cell begin.
                    // The reason: __dwCurrentVOBUSA is used to keep resume information.
                    // When resume play, CELL_CellInitial() will be called and __dwCurrentVOBUSA will be clear as zero.
                    // And, assign the proper value to __dwCurrentVOBUSA when NV sector is found.
                    // So, if it's too late to find NV sector done, the value is zero and is un-expected.
                    // For resuem play case, we will call CELL_CellInitial() + CELL_TimeSearch(CELL_TIME_VOBU, dwTime)
                    // Suppose, we can assign __dwCurrentVOBUSA w/ dwTime to solve this problem.
                    __dwCurrentVOBUSA = __dwVOBUSA;
                }
                //Aron2.38, check system supports still resuming or not
                if(UTL_QueryCapability(QUERY_SUPPORT_STILLRSM))
                {
                    //Aron2.38, It means we will do the still resuming and prepare to do SCAN I picture
                    //This is the 1st stage of still resuming.
                    if(__bStillRSM)
                    {
                        UTL_TransferCommandID(KEY_SCF);
                        DISP_STCFreeze(0, DISP_FORCE_FREEZE_STC);
                        //UTL_OutputShowTime();
                    }
                }

                break;
    }

#endif  //#ifndef NO_DVD
    return TRUE;
}
//DVD_036GOTOTIME end


// LLY1.50, collect force linear playback testing code into a API
//  **********************************************************************************************
//  Function    :   _ForceLinearPlayback
//  Description :   Force enter linear playback mode, the playback range is 1st VOBU to last VOBU
//  Arguments   :   None
//  Return      :   TRUE, enter force linear playback mode
//                  FALSE, don't enter force linear playback mode, ie VOBU by VOBU
//  **********************************************************************************************
BYTE _ForceLinearPlayback(void)
{
// DVD_172Micky, debug performance codes.
#ifdef  FORCE_LINEAR    // for test performance
	// Micky0.66-909. let each go the linear path
    if(__dwVOBUSA==0) // __dwVOBUSA == 0, means 1st VOBU of current cell.
    {

        // Give range from 1st VOBU to last VOBU within this cell
        __dwVOBUStart = __dwCellFVOBUSA + __dwVOBUSA;
        __dwVOBUEnd = __dwCellLVOBUEA;
        __dwTimeBegin = __dwVOBUStart;
        __dwTimeEnd = __dwVOBUEnd;
        // LLY2.35, give start and end time for UTL_PlayFromTime() since the API is updated
        UTL_PlayFromTime(__dwVOBUStart, __dwTimeEnd);

        // Change Cell action to VOBU_PLAYING to continue playback to end.
        __bCellAction=VOBU_PLAYING;

        DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "Force enter linear playback mode\n");
        return TRUE;
    }
#endif  //#ifdef  FORCE_LINEAR
    return FALSE;
}

// Aron 2.30, add for VOBU time control error concealment mechanism usage
DWORD __dwVOBUTIMECheck;
DWORD __dwVOBUTIMECheckInterval = 0;
DWORD __dwSTCBlockChecking = 0;
//**********************************************************************
//  Function    : CELL_Trigger
//  Description : Called when the state machine is changed to CELL_STATE
//              :
//  return      : HIBYTE, The next state (CELL_STATE, NV_COMMAND_STATE, PGC_STATE)
//              : LOBYTE, the parameter for the state
//DVD_039-1
//              : VOBU_PAYING  , means still playing a VOBU/ILVU range
//              : VOBU_END      , means the VOBU is playing to end
//              : ILVU_END      , means the ILVU is playing to end
//  Parameters  : bParame, not used
//**********************************************************************
WORD  CELL_Trigger(BYTE bParam)
{
#ifndef NO_DVD
    DWORD   dwSTC;

#ifdef CELL_FORCE_LINEAR_PLAY_TEST
//        _SwitchLinearPlayAndNVPlay(FALSE);
#endif // #ifdef CELL_FORCE_LINEAR_PLAY_TEST

    if(__bCellAction==VOBU_PLAYING)
    {
        __bCellAction=_CheckVOBUEnd();
    }

    // LLY2.77, move following procedure outside
    // (old is put within if(__bCellAction==VOBU_PLAYING) routine
    // Otherwise, CELL_Trigger() will continue go while waiting time-out for issue next SCAN
    // And, F/W will send more data during this period.
    // The bug: SCBx2 is same as SCF while playback DVD title "¤ßªÅªÅ"
    // Micky2.79, fix Ritek 1/1, repeat chapter, SCBx2, x4 will hang
    // the problem is VOBU size too small(25~36),
    // won't enter the flow VOBU_PLAYING state for checking ScanJump.
    // move the ScanJump at one place.
    // sometimes will find IFSC was got after severals NV+VOBUs
    // Why IFSC wasn't detected immediately after VOBU sent?
    // The reason is the bitstream feeding speed is quick.
    // seems don't need check command??? Digest issue???
    // Micky2.79-2, fix Ritek 1/1, SCBx2 will hang at chapter begin.
    // After move the CELL_ScanJump into (__bCellAction == VOBU_PLAYING)
    // it hangs when when CELL_ScanJump is called (_bCheckNVData = CELL_GOT_NV)
    // the reason is that __dwCurrentVOBUSA wan't updated as __dwCurrentVOBUSA
    // so calculate the wrong NV sector, cause NV can't find.
    // the __dwCurrentVOBUSA will be updated when VOBU_END only
    // need review __dwCurrentVOBUSA and __wCurrentVOBUSA.
    // as CELL_ScanJump will reference the __dwCurrentVOBUSA
    // only can be called when VOBU playing.
    if ( _bCheckNVData == CELL_NV_NONE)
    {
        // LLY1.05, always go to CELL_ScanJump() while __bModeCmd == SCF/ SCB
        //if( (__bScan==SCAN_GO) &&
        if((__bModeCmd == KEY_SCF) || (__bModeCmd== KEY_SCB))
        {
            // LLY2.36a, always break the CELL_Trigger() while CELL_ScanJump() is not done.
            //CELL_ScanJump();
            if(!CELL_ScanJump())
                return MAKEWORD(__bCellAction, CELL_STATE);

        }
    }


    // Micky0.95, fix NF250-> Highligh->Highlight change-> will play to 30s.
    // should play to 25s then force active button.
    // check ForceActiveButton
    if ( _CheckForceActive() )
    {
        __bCellActiveBTN=TRUE;
    }

    switch(__bCellAction)
    {

// Micky1.05 begin, remove
/*
//DVD_051Micky
// for TDL-002, title 06/1
#ifdef  CHECK_VOBU_E_PTM
        case    VOBU_TIME:
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// The control is for VOBU presentation time
// if STC is too small compared with VOBU_E_PTM
// then don't send data
// if the plus value is to small, less than 90000,
// then it has to wait more longer.
// And it may cause audio underflow.
// (on LVP08.01 title 11. slide show, at least >= 135000)
// if the plus value too large, then almost no wait time is needed.
// for save, use larger value that won't have effect for normal case
// generally, the diff between STC and VOBU_END_TIME, is about 0.7 seconds

                HAL_ReadInfo(HAL_INFO_STC, &__dwTemp);
                // 147000/90000-0.21(8k-2k/912kbps)
                // Micky1.25, fix anti-shock highlight don't display(MATRIX)
                // must enlarge the wait time
                // if ((__dwTemp + 130000) > __dwVOBU_E_PTM) //__dwVOBU_E_PTM <=( __dwTemp+23000) )
                if ((__dwTemp + 80000) > __dwVOBU_E_PTM) //__dwVOBU_E_PTM <=( __dwTemp+23000) )
                {
                    __bCellAction=VOBU_NEXT;
                    return MAKEWORD(VOBU_END, CELL_STATE);
                }
                else
                {
                    return MAKEWORD(VOBU_TIME, CELL_STATE);
                }
                break;
#endif  //#ifdef  CHECK_VOBU_E_PTM
*/

        case    VOBU_STILL:
#ifdef  _CELL_INFO
                DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nEnter VOBU still, wait user action\n");
#endif  // #ifdef _CELL_INFO
                return MAKEWORD(VOBU_STILL, CELL_STATE);
                break;
        case    VOBU_PLAYING:
                return MAKEWORD(VOBU_PLAYING, CELL_STATE);
                break;

        case    CELL_LAST_VOBU: // will polling here until VOBU_E_PTM
                // Micky1.25, merge the push fifo action to CELL_LAST_VOBU.
                // For the case that the data are buffered at FIFO.
                // Fix the problem: "Evita" highlight can't display
                // push all FIFO remain
                // PARSER_ActionFilter(0, PARSER_ENABLE_END_PADDING, TRUE);
                // Ming0.80a, Push video buffer to empty it.
                //            Solve NF250 TT/CC 27/01 hangs at the end of cell.
                PARSER_Command(0, PARSER_CMD_PUSH_VIDEO, 0);

// DVD_051-3Micky, do not do VOBU_E_PTM control at CELL end
// NF-200 Linear title play 304, 5-6 audio unsmooth is caused by this control
// BTW, we've add CHECK_VOBU_E_PTM already. So this control is unnecessary!
// The spirit of Rainforest slides show is OK.

                // will process the CELL still time here
                // DVD_103Micky, set __btPlayEnd=TRUE when last VOBU is sent.
                __btPlayEnd = TRUE;

                //DVD_099Micky, ref. VI3-50. Cell Commands, Button Command, Cell/VOBU still
                // are not executed during scan for/backward
                // !!! But in spec. forward/backward scan means except normal play.

                // check still time only when normal play
                // The title "The Arrival", TT/CC 01/06, cell still time=60
                if ( (__bModeCmd != KEY_SCB) && (__bModeCmd != KEY_SCF) &&
                // DVD_099Micky, KEY_FF is treated as scan forward
                     (__bModeCmd != KEY_FF) )
                    __bStillTime= __pbi_CELL. C_CAT [2];
                else
                    __bStillTime=0;

                if (!__bStillTime)
                {
                    __bCellAction=CELL_CHECK_FORCEACTIVE;
                    return MAKEWORD(CELL_CHECK_FORCEACTIVE, CELL_STATE);
                }
                else
                {
                    // enter the stage that CELL still time
                    __dwTimeStill=OS_GetSysTimer();
                    __bCellAction=CELL_STILL;

                    // Only 1 japan player will display the cell still as pause
                    // other are same as normal status.
                    return MAKEWORD(CELL_STILL, CELL_STATE); //???
                }
        case    CELL_STILL:
                // CELL still time control
                if (__bStillTime!= 0xff)    // not forever still
                {
                    // Micky2.40, till A/V buffer empty then start wait time
                    // Fix NF200, Title Menu --> 3 --> 1 --> control cell unit,
                    // the cell still should stay 5s
                    // If don't add the control, ASP will stay 2s only.
                    HAL_ReadInfo(HAL_INFO_VIDEO_REMAIN, &__dwTemp);
                    if(__dwTemp > 0x100)
                    {
                        __dwTimeStill = OS_GetSysTimer();
                        return MAKEWORD(CELL_STILL, CELL_STATE);
                    }
                    HAL_ReadInfo(HAL_INFO_AUDIO_REMAIN, &__dwTemp);
                    if (__dwTemp > 0x800)   // NF200 will remain 0x3xx.
                    {
                        __dwTimeStill = OS_GetSysTimer();
                        return MAKEWORD(CELL_STILL, CELL_STATE);
                    }

                    if ( (OS_GetSysTimer()- __dwTimeStill)> ((DWORD)__bStillTime* COUNT_1_SEC ) )
                    {
                        // DVD_171Micky, always force servo to spin up to last playes position
                        // LLY1.06, tell source to continue previous action.
                        // ie. servo will continue previous kept data sending information.
                        UTL_PreStartServo(__dwTimeNow, ACTION_CONTINUE);
                        // cell still time end. then check force active button.
                        __bCellAction=CELL_CHECK_FORCEACTIVE;
                        return MAKEWORD(CELL_CHECK_FORCEACTIVE, CELL_STATE);
                    }
                }
                return MAKEWORD(CELL_STILL, CELL_STATE); //???
                break;

        case    CELL_CHECK_FORCEACTIVE:
                // check if any force active button
                if (__bForceActiveBTNN)
                {
                    if ( _CheckForceActive() )//==CELL_ACTIVE_BTN )
                    {
                        __bCellActiveBTN=TRUE;
                    }
                    else
                        return MAKEWORD(CELL_CHECK_FORCEACTIVE, CELL_STATE);
                }
                __bCellAction=CELL_END;
        // pure CELL_END state
        case    CELL_END:
                if (__bCellActiveBTN)
                    return MAKEWORD(CELL_CHECK_FORCEACTIVE, NV_COMMAND_STATE);
                return MAKEWORD(CELL_END, PGC_STATE);
                break;

               // ILVU play end
        case    ILVU_END:
                // need process if seamless Angle change
                // must start from the ILVUSA sepcified at DSI
                if (__bAngleChange) // need do angle change
                {
                    //DVD_051Micky, can't do angle change whem last ILVU
                    // the SML_AGL should be 0x7fffffff
                    // NF-200, can't do angle change in 01:09:00
                    _bIndex=__bAngle-1;
// DVD_103Micky, reduce DSI
#ifdef  REDUCE_DSI
                    // read AGLI total 54 bytes
                    // could read less...
                    // Micky0.65-909, use bytes unit
                    //Ming0.80, use PCI and DSI directly.
#if 0
                    HAL_CopyDRAM ((DWORD)DSI_SMLAGLI_BASE, (DWORD)__cBuffer, SML_AGLI_BYTE);
                    // check if the AGLI data is non-zero
                    // each AGLI has 6 bytes
                    _bIndex = (_bIndex*6);
                    __dwTemp =  MAKELONG(MAKEWORD(__cBuffer[_bIndex+3], __cBuffer[_bIndex+2]),
                                MAKEWORD(__cBuffer[_bIndex+1], __cBuffer[_bIndex]));
#else
                    // Cannot use DWORD* to access SML_AGLI. It maybe is mis-alignment.
                    // Mis-alignment access result in segmentation fault.
//                    __dwTemp = *(DWORD*)&_pDSI->SML_AGLI[_bIndex][0];
//                    __dwTemp =  MAKELONG(MAKEWORD(_pDSI->SML_AGLI[_bIndex][3],
//                                                  _pDSI->SML_AGLI[_bIndex][2]),
//                                         MAKEWORD(_pDSI->SML_AGLI[_bIndex][1],
//                                                  _pDSI->SML_AGLI[_bIndex][0]));
			        __dwTemp = COMUTL_ReadBufferDWORD ( (char *)&(_pDSI->SML_AGLI[_bIndex]), 0);
#endif
                    if (__dwTemp != 0x7fffffff)
                    if (__bSeamlessAngleChange)  // info. from C_PBI
                    {
                        __bAngleChange=FALSE;
                        // seamless angle change, must reference DSI
                        __dwVOBUSA= __dwCurrentVOBUSA + __dwTemp;
                        __bCellAction=VOBU_START;
                        // DVD_161Micky, fix NF200-> seamless angle change angle 9->01:08:19->
                        // change to angle 1, will skip a range don't play
                        // can't update cell LVOBUEA at the boundary.
                        // so do the action only when angle is changed within cell
                        _UpdateCellInfo();

                        break;
                    }
#else
                    if ( MAKELONG(MAKEWORD(cDSI.SML_AGLI[_bIndex][3],cDSI.SML_AGLI[_bIndex][2]),
                                 MAKEWORD(cDSI.SML_AGLI[_bIndex][1],cDSI.SML_AGLI[_bIndex][0])) != 0x7fffffff)
                    if (__bSeamlessAngleChange)  // info. from C_PBI
                    {
                        __bAngleChange=FALSE;
                        // seamless angle change, must reference DSI
                        __dwVOBUSA= __dwCurrentVOBUSA +
                                (MAKELONG(MAKEWORD(cDSI.SML_AGLI[_bIndex][3],cDSI.SML_AGLI[_bIndex][2]),
                                MAKEWORD(cDSI.SML_AGLI[_bIndex][1],cDSI.SML_AGLI[_bIndex][0])) & 0x7FFF);
                        // DVD_161Micky, fix NF200-> seamless angle change angle 9->01:08:19->
                        // change to angle 1, will skip a range don't play
                        // can't update cell LVOBUEA at the boundary.
                        // so do the action only when angle is changed within cell
                        _UpdateCellInfo();
                        __bCellAction=VOBU_START;
                        break;
                    }
#endif
                }
        case    VOBU_END:   //release from VOBU still
            // DVD_161aMicky,Angle change will go here
            // or repeat A-B, will do angle search.
            if (__bAngleChange && !__bSeamlessAngleChange)
            {
                DWORD dwNsmlAngleDest;
                //DVD_051Micky, clear __bAngleChange after AGL is set
                //__bAngleChange=FALSE;
                // Micky0.65-909, use bytes unit.
                // Ming0.80a, Use __bAngle to refer to the correct angle info.
                //_bIndex=(__bAngle-1)*4;

                //DVD_051Micky, Read angle informtaiont first
                //Ming0.80, use PCI and DSI directly.
                //HAL_CopyDRAM (PCI_NSML_AGLI+_bIndex, (DWORD)__cBuffer, 1*4);
                //dwNsmlAngleDest=
                //    MAKELONG(MAKEWORD(__cBuffer[3],__cBuffer[2]),
                //    MAKEWORD(__cBuffer[1],__cBuffer[0]));
                // Ming0.80, NSML_AGLI must be DWORD alignment.
                // Ming0.80a, Use __bAngle to refer to the correct angle info.
                //dwNsmlAngleDest = *(DWORD*)&_pPCI->NSML_AGLI[__bAngle-1][0];
                dwNsmlAngleDest = COMUTL_ReadBufferDWORD ( (char *)&(_pPCI->NSML_AGLI[__bAngle-1]), 0);

                dwNsmlAngleDest&=0x7FFFFFFF;   // bit 32 is direction bit

                // must check NSML_AGLI is not 0x7fffffff then do angle data change
                if (dwNsmlAngleDest != 0x7fffffff)
                {
                    // direction flag
                    // DVD_155Micky, fix non-seamless angle change will have block[NF-200]
                    //if ( !( __cBuffer[_bIndex]&0x80 ) )
                    // Ming0.80a, Use __bAngle to refer to the correct angle info.
                    //if ( !( __cBuffer[0]&0x80 ) )
                    if(!(_pPCI->NSML_AGLI[__bAngle-1][0] & 0x80))
                    {
                        __dwVOBUSA=__dwCurrentVOBUSA + dwNsmlAngleDest;
                    }
                    else
                    {
                        // DVD_161aMicky,
                        // fix NF-200, NSML, angle change9->1 at 00:10:xx, will jump to menu
                        // as direction flag is back, __dwCurrentVOBUSA=0;(1st VOBU)
                        // as the angle change/ repeat ab search angle will go here
                        // Now only boundary angle change will come here.
                        if (__dwCurrentVOBUSA < dwNsmlAngleDest)
                        {
                            // record as LB format first
                            __dwVOBUSA = __dwCellFVOBUSA + __dwCurrentVOBUSA - dwNsmlAngleDest;
                            // !!! this will cause repat A-> angle change-> repeat B error!
                            // fix next version(1.62???)
                            // update new angle cell FVOBUSA
                            __dwCellFVOBUSA= (__pbi_CELL).C_FVOBU_SA;
#ifdef  USE_LITTLE_ENDIAN
                            COMUTL_SwapDWORD ( &__dwCellFVOBUSA );
#endif

                            __dwCellFVOBUSA += _dwFirst_VOBS;
                            // record as RLBN format first
                            __dwVOBUSA -=__dwCellFVOBUSA;
                        }
                        else
                        {
                            __dwVOBUSA=__dwCurrentVOBUSA - dwNsmlAngleDest;
                        }
                    }


                    // LLY1.50, force STC freeze before issue _PGC_BitsDiscontinue()
                    // Since, it will issue decoder stop, and STC will be reset to zero.
                    // Used to fixe bug #723: OSD will become 0 while playback NF-250 and do
                    // Title Menu(1)->4.Angle Test->2.Non-seamless Multi Angle->Test Start[13/2]
                    // -> Swich Angle
                    // Notice: need change it as wait next STC after decoder stop
                    HAL_ReadInfo(HAL_INFO_STC, &__dwSTCValue);
                    DISP_STCFreeze(__dwSTCValue, DISP_FORCE_FREEZE_STC);

                    //DVD_051Micky, clear __bAngleChange after AGL is set
                    __bAngleChange=FALSE;
                    // Micky1.24, fix multi-angle switch not immediately when anti-shock.
                    // do time search immediately.
                    // update cell information first and do bitstream dis-continue by PGC function.
                    // fix NF200-> seamless angle change angle 9->01:08:19->
                    // change to angle 1, will skip a range don't play
                    // can't update cell LVOBUEA at the boundary.
                    // so do the action only when angle is changed within cell
                    _UpdateCellInfo();
                    _PGC_BitsDiscontinue ( DISCONTINUE_AV_ONLY );

                    DISP_STCFreeze(__dwSTCValue, DISP_WAIT_NEXT_STC);

                    // Ming0.80a, The following codes is used only for CT908 anti-shock.
#if 0
                    if ( UTL_QueryCapability ( QUERY_SUPPORT_ANTISHOCK) )
                    {
                        if ( (__wTimeCellBegin + __wTimeCurrentDisplay ) < __wTimeTitle )
                        {
                            __wTemp = __wTimeCellBegin + __wTimeCurrentDisplay;
                            NV_TitleTimePlay(__wTemp);
                            __bCellAction = CELL_NOACTION;
                            break;
                        }
                    }
#endif  // #if 0

                    // recover to original command
                    UTL_TransferCommandID(__bModeCmd);
                    //Kevin1.05, avoid the bo noise when angle switch
                    CHIPS_OpenAudio(TRUE);

                    // Micky1.07, Fix NF200 non-seamless angle change-> angle switch video will flicker when P->P
                    HAL_ControlAVSync (HAL_AVSYNC_VIDEOMASTER, 1);

                    __bCellAction=VOBU_START;
                    __bSkip1Sec=SKIP_PREPARE;

                    // DVD_161Micky, fix NF200-> seamless angle change angle 9->01:08:19->
                    // change to angle 1, will skip a range don't play
                    // can't update cell LVOBUEA at the boundary.
                    // so do the action only when angle is changed within cell
                    // Micky1.24, update information right after angle change is done.
                    //_UpdateCellInfo();
                    break;
                    //DVD_051Micky, check NSML_AGLI data valid then do angle change
                }
            }
//DVD_036GOTOTIME
            //DVD_041-2
            if (__bSkip1Sec==SKIP_NOW)
            {
                __bSkip1Sec=SKIP_NONE;
// DVD_103Micky, reduce DSI
#ifdef  REDUCE_DSI
                // Micky2.31, reduce codes(26 bytes)
                //__dwVOBUSRI = _SearchFWDI((BYTE)19);
                //Ming0.80, use PCI and DSI directly.
                __dwVOBUSRI = _SearchFWDI(19);

#ifdef  _DEBUG_DSI
#ifdef    SUPPORT_PRINTF
                _bIndex=19*4-1;
                __dwTemp = MAKELONG(MAKEWORD(cDSI.VOBU_SRI[_bIndex], cDSI.VOBU_SRI[_bIndex-1]),
                                    MAKEWORD(cDSI.VOBU_SRI[_bIndex-2], cDSI.VOBU_SRI[_bIndex-3]));
                if (__dwTemp != __dwVOBUSRI)
                {
                    DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\n[DSI_ERROR]VOBUSRI=%lu", __dwVOBUSRI);
                }
#endif
#endif
#else
                _bIndex=19*4-1;
                __dwVOBUSRI = MAKELONG(MAKEWORD(cDSI.VOBU_SRI[_bIndex], cDSI.VOBU_SRI[_bIndex-1]),
                                        MAKEWORD(cDSI.VOBU_SRI[_bIndex-2], cDSI.VOBU_SRI[_bIndex-3]));
#endif
                __dwVOBUSA+=__dwVOBUSRI&0x3fffffff;   // bit 31/30 is video flag
                __bCellAction=VOBU_NEXT;
                break;
            }
            // DVD_171-2Micky, re-define the parameter for _bEnableTimeSearch
            if (_bEnableTimeSearch==CELL_TIMESEARCH_FREEZE)
            {
                // LLY1.05, not need extra SCAN CMD to force leave SCAN mode for CT909
#if 0
                // DVD_275Micky, force to leave scan mode
                // fix golden gun 1/21(2nd cell)-> SCFx4->prev wait 2s for IFSC.
                // now is NEW_NV got state, it's safe to leave scan.
                if (__bScan == SCAN_GO)
                {
                    COMDEC_Command(MODE_SCAN, 0);
                    __bScan = SCAN_NONE;
                }
#endif  // #if 0
                __bCellAction=VOBU_END;
                return MAKEWORD(VOBU_END, PGC_STATE); //???
            }
            // DVD_171-2Micky, re-define the parameter for _bEnableTimeSearch
            // need search VOBU time until specified time is reached.
            if (_bEnableTimeSearch==CELL_TIMESEARCH_TIME)
            {
                // LLY2.32, porting Micky's code for using time map table
                // Micky07312006 begin, for TMAP
#ifdef	SUPPORT_TMAP_SEARCH
                if (_dwSearchTime == 0xffffffff)
            	// means already reach the destination
                {
                	_bEnableTimeSearch = CELL_TIMESEARCH_NONE;
                }
                else
#endif	//#ifdef	SUPPORT_TMAP_SEARCH
                // Micky07312006 end ...
                {
                    _CellVOBUSearch();
                }

                // DVD_171-2Micky, re-define the parameter for _bEnableTimeSearch
                if ( _bEnableTimeSearch == CELL_TIMESEARCH_NONE )
                {
                    // LLY2.32, porting Micky's code for using time map table
                    // Micky07312006 begin, for TMAP
#ifdef	SUPPORT_TMAP_SEARCH
                    _dwSearchTime = 0xffffffff;
                    __dwVOBUEnd = 0;	//TMAP, as the VOBU_NEXT stage will check if out of cell
#endif	//#ifdef	SUPPORT_TMAP_SEARCH
                    // Micky07312006 end ...

                    // specified time is reached.
                    // DVD_102Micky, fix MI2 01/03-> gototime other chapter, sp still remain
                    // must reset A/V/sp for discontinue
                    // or subpicture may stay until a new sp comes
                    // !!! but reset video must issue when video buffer still has data

                    // Ming0.75, If reset audio, video and SPST simultaneously,
                    //           call HAL_Reset(HAL_RESET_AVSPST).
                    //HAL_Reset(HAL_RESET_AUDIO);
                    //HAL_Reset(HAL_RESET_SPST);

                    //Ming0.72, Move reset from _CC_GoTimeAction to cell.c.
                    //          When found the destination VOBU.
                    //          Will do the reset actions.
                    //HAL_Reset(HAL_RESET_VIDEO);
                    HAL_Reset(HAL_RESET_AVSPST);


                    //Ming0.72, must retore the original command after reset.
                    UTL_TransferCommandID(__bModeCmd);

                    // ** TCH1.07-908; begin... Add for Panasonic 3/1, LPCM w/ Still under repeatAB.
                    // VIDEO_MASTER should add the protection....(no video pts to update STC, audio will wait...)
                    HAL_ReadInfo(HAL_INFO_STILL, &__dwTemp);
                    if (!__dwTemp)
                    {
                    	HAL_ControlAVSync ( HAL_AVSYNC_VIDEOMASTER, 1 );   // ** TCH1.00-1-908; // ** TCH1.01-908;  for RepeatAB
                    }
                    // LLY2.31, must change as audio master (not only don't issue video master is ok)
                    // Since, F/W will issue video master first while bitstream dis-continue.
                    else
                    {
                    	HAL_ControlAVSync ( HAL_AVSYNC_VIDEOMASTER, 0 );   // ** TCH1.00-1-908; // ** TCH1.01-908;  for RepeatAB
                    }
// Micky1.02, fix time search forward, will hang at below loop(after total reset)
// video wait pic size to become positive value
// but cell wait STC to reach VOBU_E_PTM to send next VOBU
// need investigate why can't detect 1st video pts
// must force to update STC before play dedicated VOBU.
// can remove the force reset STC when the problem is cleared
                    _bForceResetSTC = TRUE;
                }
                else
                {
                    // specified time is not reached.
                    // __dwVOBUSA is for next search NV.
                    // clear the check NV_INT state before search next NV.
                    // ??? seems not necessary.
                    /// _bCheckNVData = CELL_NV_NONE;
                }

                __dwCurrentVOBUSA=__dwVOBUSA;

                // DVD_051Micky, fix Time search will enter VOBU_E_PTM
                // But NV sector should not check.
                __bCellAction=VOBU_NEXT;
                return MAKEWORD(VOBU_PLAYING, CELL_STATE);
            }
            // [1] Check if the first NV sector interrupt has got
            //     if so, reference NV data to play the remain VOBU range
            // VOBU_END, check if NV sectors end(after NV_INT is detected)
            if ( _bCheckNVData==CELL_GOT_NV)
            {
                _bCheckNVData=CELL_NV_NONE; // clear the NV state as none.
            	// Micky0.66-909. clear NV flag
            	PARSER_QueryEvent( 0, PARSER_EVENT_NV_PACK, TRUE );

                // record the value for change angle use
                __dwCurrentVOBUSA = __dwVOBUSA;

                // Micky1.25, fix "The Twister" 1/1 1st NV recorsd incorrect __dwVOBUSRI(0x943414c1)
                // Normally, __dwVOBUEA = 0 means only one NV sector without A/V sector
                // set as linear for the abnormal
            	// but time search still fail, as it will go tthrough VOBU_NEXT.
                __bCellAction=VOBU_PLAYING;

                // LLY2.32, porting Micky's code for error protection code while SRI value is 0x3ffffff
                // Micky07312006 begin
                // mark the codes, as it will cause last VOBU to be done as: NV+VOBU(normal)+VOBU(last sector, last sector-1)
                // this will cause 909 abnormal when normal play crossing cell.
#if 0
                // 0x3fffffff  or large value will go the same path.
                if ( (__dwVOBUSRI & 0x3fffffff) > __dwCellLVOBUSA )
                {
                    // Micky1.26-2, fix Dolby test 28/2- play to 14s, OSD will jump to 29s.
                    // the problem is anti-shock only. When all the cell data are sent.
                    // as CELL_LINEAR, the show time will accord to CELL time.
                    // for last VOBU, don't set linear.
                    if (__dwVOBUEnd < __dwCellLVOBUSA)
                    {
                        // still not play to last VOBUSA
                        __bCellState = CELL_LINEAR;
                        _bEnableTimeSearch=CELL_TIMESEARCH_NONE;
                    }
                    __dwVOBUStart= __dwVOBUEnd + 1;
                    __dwVOBUEnd=__dwCellLVOBUEA;
                }
                else
#endif
                // Micky07312006 end
                {
                    // LLY2.32, porting Micky's code for error protection code while SRI value is 0x3ffffff
                    // Micky07312006 begin
                    // when __dwVOBUEA=0, will assume next sector is NV sector
                    // exception:
                    // (The Twister 1/1 1st NV sector has the case that __dwVOBUEA=0, it's title encoding error)
                    // next flow will check __dwVOBUSRI, and the flow will go linear)
                    if (__dwVOBUEA ==0)
                    {
                        // do nothing to simulate VOBU play end
                        // and treat next sector as NV sector
                        // the next flow will do time wait then VOBU_NEXT
                        __dwVOBUSA ++;

                        // LLY2.35, must assign cell action as VOBU_END while the VOBU only has NV sector
                        // Otherwise, can't playback anything after detection DVD title "Doom"
                        //return MAKEWORD(VOBU_PLAYING, CELL_STATE);
                        __bCellAction=VOBU_END;
                        return MAKEWORD(VOBU_END, CELL_STATE);
                    }
                    // Micky07312006 end

                    // Current VOBU end address
                    __dwVOBUEnd=__dwVOBUStart+__dwVOBUEA;

                    // LLY2.32, porting Micky's code for error protection code while SRI value is 0x3ffffff
                    // Micky07312006 begin
                    // do the protection when the __dwVOBUEA is out of range
                    if (__dwVOBUEA > (__dwCellLVOBUEA-__dwCellFVOBUSA) )
                    {
                    __dwVOBUEnd = __dwCellLVOBUEA;
                    }
                    // Micky07312006 end

                    __dwVOBUStart+=MIN_VOBU;

                    //__bCellAction=VOBU_PLAYING; //CELL_PLAYING;
                }
                // play the remain VOBU range
                __dwTimeBegin = __dwVOBUStart;
                __dwTimeEnd = __dwVOBUEnd ;
                // Micky0.75, if issuing UTL_PlayFromTime(Start, Start-1)
                // can't wait event_complete.(parser start, but srcfilter don't send any data
                // don't call it.
                if (__dwVOBUEA != 0)	// Only NV sector
                {
                    // LLY2.35, give start and end time for UTL_PlayFromTime() since the API is updated
                    UTL_PlayFromTime (__dwVOBUStart, __dwTimeEnd) ;
                }

                //SERVO_ReadSectors(__dwVOBUStart, __dwVOBUEnd);
#ifdef  _DEBUG_VOBU
                DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nVOBU=%lx -- %lx", __dwVOBUStart, __dwVOBUEnd);
#endif

                // DVD_103Micky, must play ILVU by ILVU control
                // from 1.03, __dwNextILVUSA will be referenced.
                // Micky1.25, check the correctness of __dwVOBUSRI.
                // Aron2.36, If the __dwNextILVUSA = 0, just reference to next vobu
                // Otherwise, it will repeat same ILVU
                // Scratch%50 DVD title made by J500 occurs "repeat same vobu" problem
                if ( (__bInterleaved) && (__dwVOBUEnd >= __dwILVUEnd) && (__dwNextILVUSA != 0))
                {
                    __dwVOBUSA += __dwNextILVUSA;
                }
                else
                {
                    // Next VOBU start address
                    __dwVOBUSA+=__dwVOBUSRI&0x3fffffff;   // bit 31/30 is video flag
                }
                // Micky0.67-909, if issuing UTL_PlayFromTime(Start, Start-1)
                // can't wait event_complete.
                // by pass the stage to VOBU_END.(Can't by pass to VOBU_TIME, as need to process VOBU_END then VOBU_TIME)
                if (__dwVOBUEA == 0)	// Only NV sector
                {
                	__bCellAction = VOBU_END;
                    return MAKEWORD(VOBU_END, CELL_STATE);
                }
                return MAKEWORD(VOBU_PLAYING, CELL_STATE);
            }
            // LLY2.32, porting Micky's code for error protection code while SRI value is 0x3ffffff
            // Micky07312006 begin
            // The checking about VOBU is not proper, it may issue PlayFromTime(A,B), but B is smaller than A
            // it causes 909 has problem, the play may hang(maybe parser...issue stop??)
            // The checking should not put after NV-got.
            // Should check after NV-VOBU range play end
            else
            {
                // some title issue:
                // The twister 1/1 1st NV sector, _FWDINext is encoded as 0x943414c1, __dwVOBUEA is encoded as 0
                // check if the __dwVOBUSRI is normal or not.
                if ( (__dwVOBUSRI & 0x3fffffff) > __dwCellLVOBUSA )
                {
                    __dwVOBUStart= __dwVOBUEnd + 1;
                    __dwVOBUEnd=__dwCellLVOBUEA;
                    __dwTimeBegin = __dwVOBUStart;
                    __dwTimeEnd = __dwVOBUEnd ;

                    if (__dwTimeEnd < __dwTimeBegin)
                    {
                        // The __dwVOBUSRI is normal, as no more data to be played
                        __bCellAction = CELL_LAST_VOBU;
                        return MAKEWORD(VOBU_PLAYING, CELL_STATE);
                    }

                    // The __dwVOBUSRI is abnormal, appears too early
                    // set the flow as linear
                    __bCellAction = VOBU_PLAYING;
                    __bCellState = CELL_LINEAR;
                    _bCheckNVData = TRUE;

                    // LLY2.32, ask parser to stop while finding NV sector
                    // Notice: only enable it while linear play mode
                    //         and must clear it while NV re-find case.
                    PARSER_ActionFilter(0, PARSER_ENABLE_NV_PAUSE, TRUE);

                    // LLY2.35, give start and end time for UTL_PlayFromTime() since the API is updated
                    UTL_PlayFromTime (__dwVOBUStart, __dwTimeEnd) ;

#ifdef  DUMP_CELL_INFO
                    DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\n[1]Linear %lu-%lu", __dwVOBUStart, __dwVOBUEnd);
#endif  //#ifdef  DUMP_CELL_INFO

                    return MAKEWORD(VOBU_PLAYING, CELL_STATE);
                }
            }
            // Micky07312006 end

            // must prior to VOBU_TIME check
            // DVD_104Micky, only normal play will enable VOBU still
            if (__bVOBUStill && (__bModeCmd==KEY_PLAY))      // info. from C_PBI
            {
                // DVD_161Micky, remove the pause display when cell still
                // it looks quite strange in display mode
                // Only 1 japan player will display as pause
                // other are same as normal status.
                /*
                // DVD_102Micky, show VOBU still as pause
                __btPlaying=FALSE;
                __btPause=TRUE;
                OSD_OUTPUT_MACRO(MSG_PAUSE, NULL, 0xff);
                */
                // Micky0.96, Fix NF250 "VOBU still" subpicture will disappear after 3 seconds. Hold STC value by VSYNC.
                // use the latest STC. There 3 cells(0~5)(5~9)(9~14). 3rd cell will issue new STC
                HAL_ReadInfo(HAL_INFO_STC, &dwSTC);
                DISP_STCFreeze(dwSTC, DISP_FORCE_FREEZE_STC);
                // LLY1.06, enable force freeze STC flag
                _bForceFreezeSTC=TRUE;

                __bCellAction=VOBU_STILL;
                // DVD_104Micky, enter VOBU still, and last VOBU has sent
                // must push ififo first
                // sequence end codes happen to be last bytes of sector.
                // fix "Fight Club Disc2", at STOP->41/14, 43/90, 45/15 still pic.
                // can't display(VBI is not enabled)
#ifdef  _DEBUG_CELL_RANGE
                DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\n[VOBU STILL]");
#endif
                if (__dwVOBUEnd >= __dwCellLVOBUEA)
                {
#ifdef  _DEBUG_CELL_RANGE
                    DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, ", LastVOBU has played[VOBU STILL]");
#endif

                    // MickyDVD_277a, the push IFIFO action is necessary for ATAPI/IF only.
                    // for DVDIF, it sends 2064 bytes 12+2048+4,
                    // so seq. end code last byte won't be buffered in fifo.
                    // but it's still OK for DVDIF even do the action extra.
                    // must push out ififo, for sequence end codes.
                    // LLY.276p, push data unit has changed : BYTE --> DWORD
                    // push out any FIFO remain..
                    // PARSER_ActionFilter(0, PARSER_ENABLE_END_PADDING, TRUE);
                }

               // let other process VOBU still until user release
               // when still is released, go next VOBU
               return MAKEWORD(VOBU_STILL, PGC_STATE); //???
           }

// don't do VOBU presentation time control
// as this method will cause audio underflow.(on LVP08.01 test disc 11. slide show)
// now move the control to end of CELL
// and also need modifying the calculation of time

            // [2] A whole VOBU range is played end
            //     need reference NV data for playing next VOBU
            // Micky1.05 begin
            //__dwVOBU_E_PTM = _pPCI->PCI_GI.VOBU_E_PTM;

            //Aron2.37, The error concealment flow added in 2.32 may lead __dwVOBU_E_PTM does not be updated
            //Without updating the end of presentation, it may lead system wait a long time when current cell is played to the end.
            //Therefore, it need to be moved to _DumpNVData to update __dwVOBU_E_PTM/__dwVOBU_S_PTM
            //And clean the variable in CELL_Initial
            // Aron2.30, keep VOBU presentation start
            //__dwVOBU_S_PTM = COMUTL_ReadBufferDWORD ( (char *)&(_pPCI->PCI_GI.VOBU_S_PTM), 0);
            //__dwVOBU_E_PTM = COMUTL_ReadBufferDWORD ( (char *)&(_pPCI->PCI_GI.VOBU_E_PTM), 0);

#ifdef  DEBUG_VOBU_TIME
            HAL_ReadInfo(HAL_INFO_STC, &dwSTC);
            DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nVOBU(%lu) play end at %lu, gap(%lu)", __dwVOBU_E_PTM, dwSTC, __dwVOBU_E_PTM-dwSTC);
#endif
#ifdef  CHECK_VOBU_E_PTM
            if (_Decide_VOBU_Control() )
            {
                __bCellAction=VOBU_TIME;

                // Aron2.30, keep system timer and STC value while 1st enter VOBU_TIME
                __dwVOBUTIMECheck = OS_GetSysTimer();
                HAL_ReadInfo(HAL_INFO_STC, &__dwSTCBlockChecking);
    case    VOBU_TIME:
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// The control is for VOBU presentation time
// if STC is too small compared with VOBU_E_PTM
// then don't send data
// if the plus value is to small, less than 90000,
// then it has to wait more longer.
// And it may cause audio underflow.
// (on LVP08.01 title 11. slide show, at least >= 135000)
// if the plus value too large, then almost no wait time is needed.
// for save, use larger value that won't have effect for normal case
// generally, the diff between STC and VOBU_END_TIME, is about 0.7 seconds

                HAL_ReadInfo(HAL_INFO_STC, &dwSTC);
                // 147000/90000-0.21(8k-2k/912kbps)
                // Micky1.25, fix anti-shock highlight don't display(MATRIX)
                // must enlarge the wait time
                // if ((dwSTC + 130000) > __dwVOBU_E_PTM) //__dwVOBU_E_PTM <=( dwSTC+23000) )
//Micky0510, 50000 is ok
                if ((dwSTC + EARLIER_TIME) > __dwVOBU_E_PTM) //__dwVOBU_E_PTM <=(dwSTC+23000) )
                {
#ifdef  DEBUG_VOBU_TIME
                    // directly play next VOBU
                    DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nSend next VOBU @ %lu(gap=%lu)",  dwSTC, __dwVOBU_E_PTM-dwSTC);
#endif  //#ifdef  DEBUG_VOBU_TIME

                }
                else
                {
                    // Aron2.30-909R,STC may be blocked by little video data.
                    // Since decoder always can't finish one picture decoding
                    // Cell module needs to force sending next vobu.
                    if ( __bModeCmd != KEY_STEP && __bModeCmd != KEY_PAUSE &&__bModeCmd !=KEY_FREEZE
                         && ((int)dwSTC - (int)__dwSTCBlockChecking ) < (90000/50) ) //(90000/50) means VSYNC interval
                    {

                        __dwVOBUTIMECheckInterval += (OS_GetSysTimer() - __dwVOBUTIMECheck);

                        if(__dwVOBU_S_PTM+(__dwVOBUTIMECheckInterval/COUNT_1_SEC)*90000 >= __dwVOBU_E_PTM+45000)
                        {
                            __bCellAction=VOBU_NEXT;
                            return MAKEWORD(VOBU_NEXT, CELL_STATE);
                        }
                    }
                    else
                    {
                        __dwVOBUTIMECheckInterval = 0;
                    }
                    __dwVOBUTIMECheck = OS_GetSysTimer();
                    return MAKEWORD(VOBU_TIME, CELL_STATE);
                }
        }
#endif  //#ifdef  CHECK_VOBU_E_PTM
// Micky1.05 end
// Micky1.05 begin, remove
#if 0
//DVD_051Micky
// TDL-002, title 06/01, Ac3-> MPEG,
// the audio stream will be skipped in AC3-> back to MPEG, there's nothing for play
// so, must do control for not sending data too fast
        //TDL_002 begin
	            // Micky1.25, always record __dwVOBU_E_PTM, as other module(PGC) will reference it.
                //Ming0.80, use PCI and DSI directly.
//               HAL_CopyDRAM (PCI_VOBU_E_PTM, (DWORD)__cBuffer, 1*4);
                HAL_ReadInfo(HAL_INFO_STC, &__dwTemp);
//                __dwVOBU_E_PTM =
//                    MAKELONG(MAKEWORD(__cBuffer[3],__cBuffer[2]),
//                    MAKEWORD(__cBuffer[1],__cBuffer[0]));
//                __dwVOBU_E_PTM = _pPCI->PCI_GI.VOBU_E_PTM;
				__dwVOBU_E_PTM = COMUTL_ReadBufferDWORD ( &(_pPCI->PCI_GI.VOBU_E_PTM), 0);


#ifdef  CHECK_VOBU_E_PTM
                // only do for normal play
                // or will wait time too long, cause SCF looks hang!
                //DVD_099Micky, don't do VOBU_E_PTM check for slow/fast/step
                // it will cause Fast I/P not smooth.
                // SCF/SCB->play, should not do time control too, or will hang about 3 seconds
//                if ( (__bModeCmd != KEY_SCF) && (__bModeCmd != KEY_SCB) )

                // Micky1.22, reference audio remainder?
                // Ritek title menu(w/ o audio), must do VOBU_E_PTM control
                HAL_ReadInfo (HAL_INFO_AUDIO_REMAIN, &__dwTemp);
                // Micky1.25, fix anti-shock highlight don't display(MATRIX menu)
                // each NV sector has new HL status with larger time
                // if (__dwTemp <= 0x10)
                // Micky0.90-2, fix pocahontas english warning message display must last 10s.
                // must do VOBU time control for all when non-antiShock.
                if ( (__dwTemp <= 0x10) || (__bDomain & SPACE_MENU) || !UTL_QueryCapability ( QUERY_SUPPORT_ANTISHOCK) )

                if ( (__bModeCmd == KEY_PLAY) && (__bScan==SCAN_NONE))
                {
                __bCellAction=VOBU_TIME;
                return MAKEWORD(VOBU_PLAYING, CELL_STATE);
                }
#endif  //#ifdef  CHECK_VOBU_E_PTM
        //TDL_002 end
#endif

//DVD_039-1
        // decide if the next VOBU exist
        case    VOBU_NEXT:
                // no next ILVU exist
                //DVD_050Micky
                // If control NextILVUSA, it will happen earlier than __dwVOBUSRI
                // it will cause
                // NF-200 parental control/ non-seamless angle change cell 2->3
                // has audio noise.
                // besides, __dwNextILVUSA only has value when __bInterleaved=1
                /*
                if ( ( __dwNextILVUSA == 0xffffffff) ||
                // it means next VOBU exceed the CELL presentaion termination time
                    ((__dwVOBUSRI&0x3fffffff)==0x3fffffff) )   // bit 31/30 is video flag
                */
                // DVD_103Micky, fix "The Mummy" AC3 test can't play
                // the VOBUSRI records 0x3fffffff in 1st NV pack
                // don't use __dwVOBUSRI as check.
                if ( (__bModeCmd != KEY_SCB) && (__bModeCmd != KEY_SCF) )
                {
                    // check if last DSI(VOBU has played)
                    if (__dwVOBUEnd >= __dwCellLVOBUEA)
                    {
#ifdef  _DEBUG_CELL_RANGE
                        DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nLastVOBU has played, __dwVOBUSRI=%lx", __dwVOBUSRI);
                        if (__bInterleaved)
                        DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "[Interleaved]__dwNextILVUSA=%lx", __dwNextILVUSA);
#endif
                        // last DSI, directly play next cell
                        // reference AnnexR(playback mode8(seamless))
                        // need check next seamless playback flag of next cell
                        __bCellAction=CELL_LAST_VOBU;
                        return MAKEWORD(VOBU_END, CELL_STATE);
                    }
                    else
                    {
                        if ( !__bInterleaved )
                        {
                            // seems error, shouldn't be 0x3fffffff before end
                            if ( (__dwVOBUSRI&0x3fffffff)==0x3fffffff )   // bit 31/30 is video flag
                            {
                            __dwVOBUSA = __dwVOBUEnd-__dwCellFVOBUSA+1;
#ifdef  _DEBUG_INFO
                            DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nError !!! VOBUSRI=0x3fffffff too early!!!");
                            DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\n__dwVOBUEnd=%lx, Next VOBU=%lx", __dwVOBUEnd, __dwCellFVOBUSA+__dwVOBUSA);
#endif
                            }
                        }
                        // the VOBU start larger than the last VOBU start address
                        if (__dwVOBUSA > (__dwCellLVOBUSA-__dwCellFVOBUSA))
                        {
// LLY2.32, porting Micky's code to fix some DVD tile root menu can't play end issue
// for Harry Potter & Alexander root menu can't play end
// mark the codes
#if 0
#ifdef  _DEBUG_CELL_RANGE
                        DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nInvalid VOBUSA[VOBUSRI=%lx]", __dwVOBUSRI);
                        DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nForce end of cell");
#endif
                        __bCellAction=CELL_LAST_VOBU;
                        return MAKEWORD(VOBU_END, CELL_STATE);
#endif

// LLY2.32, porting Micky's code to fix some DVD tile root menu can't play end issue
// for Harry Potter & Alexander root menu can't play end --begin
// add the codes
                        __dwVOBUSA = __dwVOBUEnd-__dwCellFVOBUSA+1;
#ifdef  _DEBUG_CELL_RANGE
						printf("\nVOBUSA(%lx) out of range", __dwVOBUSA);
						printf("\nRe-correct __dwVOBUSA with __dwVOBUEnd");
#endif
// for Harry Potter & Alexander root menu can't play end --end

                        }
                    }
                }
                else
                {
                    // it means next VOBU exceed the CELL presentaion termination time
                    if ( (__dwVOBUSRI&0x3fffffff)==0x3fffffff )   // bit 31/30 is video flag
                    {
#ifdef  _CELL_INFO
                        DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\n__dwVOBUSA=%lu, CurrentVOBUSA=%lu, Scan=%d\n", __dwVOBUSA, __dwCurrentVOBUSA, __bScan);
#endif
                        //DVD_042-1 SCF/SCB
                        if (__bModeCmd == KEY_SCB)
                        {
                            // play the last VOBU first in SCB mode
                            // the VOBU_NEXT is triggered by send last VOBU data out
                            // but IFSC still not issued.
                            // must wait IFSC then leave
                            if ( __dwCurrentVOBUSA== (__dwCellLVOBUSA-__dwCellFVOBUSA) )
                            {
                                if (__bScan==SCAN_GO)
                                {
                                    // DVD_171-2Micky, where there's prev. VOBU w/ video exist
                                    // keep waiting IFSC before time out.
                                    // Ming0.80, If the last VOBU includes only NV, do not wait IFSC.
                                    if (__dwVOBUEA && ((OS_GetSysTimer()-__dwTimeRef) < COUNT_300_MSEC ))
                                    {
                                        __bCellAction=VOBU_PLAYING;
                                        return MAKEWORD(VOBU_PLAYING, CELL_STATE);
                                    }
                                    /// if ( (__dwCountSystem-__dwTimeRef) >= COUNT_300_MSEC )
                                    else    // over wait time, still no IFSC.
                                    {
#ifdef    SUPPORT_PRINTF
                                        DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nCan't get last VOBU IFSC after 0.3 seconds");
#endif
                                        // no Video data within VOBU?
                                        // record prev. VOBU that has video VOBU
                                        // VOBU_SRI
                                        // (the 1st) FWDI Video, the first following VOBU that has video
// DVD_103Micky, reduce DSI
#ifdef  REDUCE_DSI
                                        // Micky2.31, reduce codes
//                                        __dwVOBUSRI = _SearchFWDI((BYTE)42);
                                        //Ming0.80, use PCI and DSI directly.
                                        __dwVOBUSRI = _SearchFWDI(42);

#ifdef  _DEBUG_DSI
#ifdef  SUPPORT_PRINTF
                                        _bIndex=(42*4)-1;
                                        __dwTemp=
                                                MAKELONG(MAKEWORD(cDSI.VOBU_SRI[_bIndex],
                                                cDSI.VOBU_SRI[_bIndex-1]),
                                                MAKEWORD(cDSI.VOBU_SRI[_bIndex-2],
                                                cDSI.VOBU_SRI[_bIndex-3]));
                                        if (__dwTemp != __dwVOBUSRI)
                                        {
                                            DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\n[DSI_ERROR_2]VOBUSRI=%lu", __dwVOBUSRI);
                                        }
#endif
#endif
#else
                                        _bIndex=(42*4)-1;
                                        __dwVOBUSRI=
                                                MAKELONG(MAKEWORD(cDSI.VOBU_SRI[_bIndex],
                                                cDSI.VOBU_SRI[_bIndex-1]),
                                                MAKEWORD(cDSI.VOBU_SRI[_bIndex-2],
                                                cDSI.VOBU_SRI[_bIndex-3]));
#endif
                                        // DVD_171-2Micky, when VOBUSRI=0x3fffffff,(Ref. VI4-150)
                                        // means the time exceeds the start presentation of a cell.
                                        // != 0x3fffffff, will play the prev. VOBU.
                                        // == 0x3fffffff, will just treat as cell end.
                                        if ( (__dwVOBUSRI&0x3fffffff) != 0x3fffffff )
                                        {
                                            __dwVOBUSA=__dwCurrentVOBUSA-(__dwVOBUSRI&0x3fffffff);
                                            __dwCurrentVOBUSA=__dwVOBUSA;
                                            __bCellAction=VOBU_START;
                                            break;
                                        }
                                    }
                                    // DVD_171-2Micky, where there's prev. VOBU w/ video exist
                                    // keep waiting IFSC before time out.
                                    // move to above.
                                    /*
                                    __bCellAction=VOBU_PLAYING;
                                    return MAKEWORD(VOBU_PLAYING, CELL_STATE);
                                    */
                                }
                            }
                        }
                        // DVD_051Micky, let all macro commands go through last VOBU control

                        // the last VOBU
                        // should goto cell end state(cell command???)
                        __bCellAction=CELL_LAST_VOBU;
                        // LLY.100, push 1 DWORD data to IFIFO for
                        // "highlight can't display" in "Evita" title
                        // It's because that there is 1 BYTE data will be kept
                        // between parser and IFIFO
                        return MAKEWORD(VOBU_END, CELL_STATE);
                    }
                }


        // The stage to process each VOBU start, and will sent NV sector.
        case    VOBU_START:
             // LLY1.50, collect the procedure of force linear playback code into a API
            if(_ForceLinearPlayback())
            {
                break;
            }

            //Micky0406 do before _bCheckNVData
            // clear NV flag
            PARSER_QueryEvent( 0, PARSER_EVENT_NV_PACK, TRUE );

            // Go normal path, ie. VOBU by VOBU playback while don't enter linear playback mode (test only)

            // clear the NV state, bit [3:0]
            _bCheckNVData &= 0xF0;

            //Aron2.38, check system supports still resuming or not
            if(UTL_QueryCapability(QUERY_SUPPORT_STILLRSM))
            {
                extern DWORD __dwSeqEndCode;
                DWORD   dwScanDone;

                if ( __bStillRSM )
                {
                    HAL_ReadInfo(HAL_INFO_DECCMD_ACK, &dwScanDone);

                    //Aron2.38, After getting scan done, it means the I picture is ready & displayed.
                    //The still resuming mechanism can continue to enter 2nd stage to jump to the resuming time.
                    if( dwScanDone == MODE_SCAN_DONE )
                    {
                        //Aron2.38  we do "SCAN" to decode the still picture and it leads
                        //sequence endcode does not be decoded. It leads navigation can not
                        //recognize it as still picture when doing 2nd time pre-stop.
                        //Therefore, we restore the __dwSeqEndCode = TRUE after scan done to prevent the problem.
                        __dwSeqEndCode = TRUE;

                        _bEnableTimeSearch=CELL_TIMESEARCH_TIME;
                        _dwSearchTime=__dwStillRSMTimeSearch;
                        __bCellAction = VOBU_END;
                        __bStillRSM = FALSE;
                        HAL_ControlParser(HAL_PARSER_STOP, 0);
                        SrcFilter_Stop(__dwSFStreamID);
                        //Restore orginal play command
                        UTL_TransferCommandID(__bModeCmd);
                        DISP_STCFreeze(0, DISP_UNFREEZE_STC);

                        return MAKEWORD(VOBU_END, CELL_STATE);
                    }
                }
            }

            // assign the NV state as wait NV
            _bCheckNVData |= CELL_WAIT_NV;

            // when linear search NV(sector by sector),  don't resend NV sector
            // So, don't increase the NV sector count
            if ( !(_bCheckNVData & CELL_LINEAR_NV) )
            {
                // increase the NV sector count
                _bCheckNVData += 0x40;
            }
            // Assign the NV sector address (only one sector).
            __dwVOBUStart = __dwCellFVOBUSA + __dwVOBUSA;
            __dwVOBUEnd =__dwVOBUStart + (MIN_VOBU-1);
            __dwTimeBegin = __dwVOBUStart;
            __dwTimeEnd = __dwVOBUEnd ;
            // Ask parser and source to send the desired range
            // LLY2.35, give start and end time for UTL_PlayFromTime() since the API is updated
            UTL_PlayFromTime (__dwVOBUStart, __dwTimeEnd) ;

#ifdef  _DEBUG_VOBU
            DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nNV=%lx, [VOBUSA=%lx]", __dwVOBUStart, __dwVOBUSA);
#endif  // #ifdef _DEBUG_VOBU


            // Ming0.75, Add a new state to wait the source filter has completed.
            __bCellAction = VOBU_WAIT_NV_SEND_COMPLETE;

            // record the time that sending NV sector
            _dwTimeNV=OS_GetSysTimer();

//            DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "NV sending Time: %lx\n", _dwTimeNV);

            // for non-seamless angle change,
            // will skip 1 seconds after dest. angle address is got.
            if (__bSkip1Sec!=SKIP_NONE)
            {
                __bSkip1Sec=SKIP_NOW;
            }

            // Clear previous scan postion as 0xffffffff while on SCAN mode
            if( (__bModeCmd!=KEY_SCF) && (__bModeCmd!=KEY_SCB) )
            {
                _dwPreScanPosition = 0xffffffff;
            }


#ifdef CELL_FORCE_LINEAR_PLAY_TEST
            if((_bLinearNPFFlags & CELL_LINEAR_NPF_OK) &&
                !__bInterleaved &&
                (_bEnableTimeSearch == CELL_TIMESEARCH_NONE) &&
                ((__bModeCmd == KEY_PLAY) ||
                 (__bModeCmd == KEY_FF) ||
                 (__bModeCmd == KEY_SF) ||
                 (__bModeCmd == KEY_FREEZE) ||
                 (__bModeCmd == KEY_SCF) ||
                 (__bModeCmd == KEY_SCB) ||
                  !__bModeCmd))
            {
                 SrcFilter_Stop(__dwSFStreamID);
                HAL_ControlParser(HAL_PARSER_STOP, 0);
                if(__dwVOBUSA == 0)
                {
                    _bLinearNPFFlags |= CELL_LINEAR_NPF_UPDATE_STC;
                }
                __dwTimeBegin = __dwCellFVOBUSA + __dwVOBUSA;
                 __dwVOBUEnd = __dwTimeEnd = __dwCellLVOBUEA;
                 __bSTCRunning=TRUE;
                __bCellState = CELL_LINEAR;
                _bLinearNPFFlags |= CELL_LINEAR_NPF_RUN;
                PARSER_ActionFilter(0, PARSER_ENABLE_NV_PAUSE, TRUE);
                // LLY2.35, give start and end time for UTL_PlayFromTime() since the API is updated
                UTL_PlayFromTime (__dwTimeBegin, __dwTimeEnd) ;
                OS_YieldThread();
                return MAKEWORD(VOBU_PLAYING, CELL_STATE);
            }
#endif // CELL_FORCE_LINEAR_PLAY_TEST

            // Ming0.75, Release CPU to the other threads.
            //           Then Parser & Source Filter can go sooner.
#ifndef SUPPORT_SERVO_SOURCE
            OS_YieldThread();
#endif  // #ifndef SUPPORT_SERVO_SOURCE

            // Ming0.75, Add a new state to wait the source filter has completed.
            return MAKEWORD(VOBU_WAIT_NV_SEND_COMPLETE, CELL_STATE);
            break;

        // Ming0.75, Add a new state to wait the source filter has completed NV sector sending.
        case    VOBU_WAIT_NV_SEND_COMPLETE:
                // Ming0.80, Two cases result to leave VOBU_WAIT_NV_SEND_COMPLETE mode.
                //           1. Srcfilter has completed the NV sector read.
                //           2. Exceed 500 msec to wait for srcfilter to complete NV sector read.

                // Case 1: source complete the NV sector sending.
                SrcFilter_GetCurrentPos(&__dwTemp);
                if(__dwTemp > __dwTimeBegin)
                {
                    __bCellAction=VOBU_PLAYING;
//                    DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "NV sending done: %lx, Time: %lx\n", UTL_GetSysTimer()-_dwTimeNV, UTL_GetSysTimer());
                    _dwTimeNV=OS_GetSysTimer();
                    return MAKEWORD(VOBU_PLAYING, CELL_STATE);
                }

                // Case 2: Exceed time-out value and source don't complete the NV sector sending.
                // Notice: the time-out value must be 2 sec for servo long seek action.
                if((OS_GetSysTimer() - _dwTimeNV) > COUNT_3_SEC)
                {
                    DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "Err: Wait source complete NV sending Fail, __dwVOBUStart=%lx!!\n", __dwVOBUStart);
                    // Ming0.80, If src filter cannot complete, return to VOBU_PLAYING mode.
                    __bCellAction=VOBU_PLAYING;
                    _dwTimeNV=OS_GetSysTimer();
                    return MAKEWORD(VOBU_PLAYING, CELL_STATE);
                }

                // Otherwise, still loop @ wait NV sector sending complete.
                return MAKEWORD(VOBU_WAIT_NV_SEND_COMPLETE, CELL_STATE);
                break;

                // LLY2.32, porting Micky's code for using time map table
                // Micky07312006 begin, for TMAP
#ifdef	SUPPORT_TMAP_SEARCH
        case    TIME_SEARCH:
				if (SearchTMAPTime() == FALSE)	// don't use TMAP search
				{
					__bCellAction = VOBU_START;
				}
				break;
#endif	//#ifdef	SUPPORT_TMAP_SEARCH
                // Micky07312006 end ...
    }
#endif  //#ifndef NO_DVD
   // still keep in CELL state
   return MAKEWORD(VOBU_PLAYING, CELL_STATE);
}


//**********************************************************************
//  Function    :
//  Description :
//              :
//  Parameters  :
//**********************************************************************
void _DumpNVData(void)
{
#ifndef NO_DVD
    BYTE bIndex;

    //Ming0.80, use PCI and DSI directly.
    _pDSI = (volatile DSI*)DSI_BASE;
    _pPCI = (volatile PCI*)PCI_BASE;

    //Aron1.08-909, store the NV's start/end presentation time and UOP field
    bIndex = _wNV_UOPs_WP%10;
    //_past_NV_UOPs[bIndex].VOBU_E_PTM = _pPCI->PCI_GI.VOBU_E_PTM;
	_past_NV_UOPs[bIndex].VOBU_E_PTM = COMUTL_ReadBufferDWORD ( (char *)&(_pPCI->PCI_GI.VOBU_E_PTM), 0);
    //_past_NV_UOPs[bIndex].VOBU_S_PTM = _pPCI->PCI_GI.VOBU_S_PTM;
    	_past_NV_UOPs[bIndex].VOBU_S_PTM = COMUTL_ReadBufferDWORD ( (char *)&(_pPCI->PCI_GI.VOBU_S_PTM), 0);
//_past_NV_UOPs[bIndex].VOBU_UOP_CTL = _pPCI->PCI_GI.VOBU_UOP_CTL;
	_past_NV_UOPs[bIndex].VOBU_UOP_CTL = COMUTL_ReadBufferDWORD ( (char *)&(_pPCI->PCI_GI.VOBU_UOP_CTL), 0);
    _wNV_UOPs_WP++;

    _UpdatePCI();

    // record current VOBU end address
// DVD-103Micky, reduce DSI
    //Ming0.80, use PCI and DSI directly.
    //__dwVOBUEA = _pDSI->DSI_GI.VOBU_EA;
    __dwVOBUEA = COMUTL_ReadBufferDWORD ( (char *)&(_pDSI->DSI_GI.VOBU_EA), 0);
    if(_pDSI->SML_PBI.VOBU_SML_CAT[0] & VOBU_ILVU) // bit 14, ILVU flag
    {
        __bInterleaved=TRUE;
        //__dwNextILVUSA = _pDSI->SML_PBI.NXT_ILVU_SA;
	    __dwNextILVUSA = COMUTL_ReadBufferDWORD ( (char *)&(_pDSI->SML_PBI.NXT_ILVU_SA), 0);

#ifdef  _DEBUG_CELL_RANGE
        DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\n NextILVUSA=%lx", __dwNextILVUSA);
#endif
        //Ming0.80, use PCI and DSI directly.
        //__dwILVUEA = _pDSI->SML_PBI.ILVU_EA;
	    __dwILVUEA = COMUTL_ReadBufferDWORD ( (char *)&(_pDSI->SML_PBI.ILVU_EA), 0);

        __dwCurrentVOBUSA = __dwVOBUSA;
        __dwILVUEnd=__dwVOBUStart+__dwILVUEA ;
    }
    else
    {
        //Aron2.36, must clean the flag when it is not a ILVU
        //Otherwise, it will reference the field "next ILVU start address" to get next vobu
        //Scratch%50 DVD title made by J500 occurs "repeat same vobu" problem
        __bInterleaved = FALSE;
    }

    // record next VOBU start address
    // VPBU_SRI
    // (the 21th) FWDI Next is the same as FWDI Video most of the time
    // Micky2.31, reduce codes(19)
    //Ming0.80, use PCI and DSI directly.
    //__dwVOBUSRI = _SearchFWDI(21-1];
	__dwVOBUSRI = _SearchFWDI(21);

    // Micky2.79, fix Region2(The Lord Of The Ring, Disc1), will loop playing 1:36:10
    // The sector 2060925 VOBUSRI value is 0.
    // add the protection, when VOBUSRI value is 0, just use __dwVOBUEA to correct it.
    if ((__dwVOBUSRI&0x3fffffff) == 0)
    {
#ifdef  SUPPORT_PRINTF
        DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nError VOBUSRI=0");
#endif  //#ifdef  SUPPORT_PRINTF
        // keep the bit 31,30
        __dwVOBUSRI = (__dwVOBUSRI&0xC0000000) +__dwVOBUEA+1;
    }

    // DVD_103Micky, record last played VOBU that has video data
    // (the 42th) BWDI Video is the last VOBU that has video data
    // Micky2.31, reduce codes(28)
    //Ming0.80, use PCI and DSI directly.
    // LLY2.37, only bit[29:0] is valid for address
    // So, must &0x3fffffff to get value first
    // Otherwise, it will cause __dwVOBUSA always < __dwCellVideo_VOBUSA
    __dwCellVideo_VOBUSA = _SearchFWDI(42) & 0x3fffffff;

    if (__dwVOBUSA > __dwCellVideo_VOBUSA)
        __dwCellVideo_VOBUSA = __dwVOBUSA - __dwCellVideo_VOBUSA;
    else
        __dwCellVideo_VOBUSA=0;

// DVD_170Micky, as navigate.c will update __bANL_Ns
// cell don't need serach angles number.
#ifdef  _DEBUG_ANGLES_NUMBER
    __bTemp= __bAGL_Ns;
    //DVD_039-1, Add for non-Seamless Angle Change
    // can't use [0] tfor judging, as bit 7 of it is used for direction only
    //DVD_050aMicky
    //Use valid PCI/DSI data
    // check angles only when cell block type is angle block(VI4-100)
    if (_bAngleCheck)
    {
        if (__bSeamlessAngleChange)  // info. from C_PBI
        {
            // reference DSI for seamless angle change
            // each angle has 6 bytes data
            for ( _bIndex=0; _bIndex< 9; _bIndex++ )
            {
                //Ming0.80, use PCI and DSI directly.
                if ( !( _pDSI->SML_AGLI[_bIndex][5] ) &&
                     !( _pDSI->SML_AGLI[_bIndex][4] ) &&
                     !( _pDSI->SML_AGLI[_bIndex][3] ) &&
                     !( _pDSI->SML_AGLI[_bIndex][2] ) &&
                     !( _pDSI->SML_AGLI[_bIndex][1] ) &&
                     !( _pDSI->SML_AGLI[_bIndex][0] ))
                {
                    break;
                }
            }
        }
        else
        {
            // reference PCI for non-seamless angle change
            for ( _bIndex= 0; _bIndex< 9; _bIndex++ )
            {
                //Ming0.80, use PCI and DSI directly.
                if ( !( _pPCI->NSML_AGLI[_bIndex][3] ) &&
                     !( _pPCI->NSML_AGLI[_bIndex][2] ) &&
                     !( _pPCI->NSML_AGLI[_bIndex][1] ) &&
                     !( _pPCI->NSML_AGLI[_bIndex][0] ))
                {
                    break;
                }
            }
        }

// debug cell angle number and TT_SPR_AGL_Ns
#ifdef  SUPPORT_PRINTF
        if ( __bAGL_Ns != _bIndex)
        {
        // reference VI4-4. TT_SRP_AGL_Ns.(navigate will read it)
            DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nCell angle information(%d) doesn't match TT_SRP_AGL_Ns(%d)",
            _bIndex, __bAGL_Ns);
        }
#endif

        __bAGL_Ns= _bIndex;
        if ( __bAGL_Ns )    // exist Angle_Ns
        {
            if ( __bAGLN > __bAGL_Ns )  // ** TCH0.29;
            {
                __bAGLN= 1;
                CELL_AngleChange(__bAGLN);
            }
            else if (__bAGLN==0)
            {
                __bAGLN=1;
            }
        }
        else
            __bAGLN= NULL;
    }

    // DVD_170Micky, unused codes
    // for angle cell, PGC will search correct angle for play
    // for repeat A-B change angle, now use Gotime method
    // so CELL don't need do angle search
    // It's different from previous VOBU Status; notify a MSG
    if (_bAngleCheck || (__bTemp != __bAGL_Ns))
    {
        _bAngleCheck=0;
        // forever display angle
        if (__bAGL_Ns)
        {
            // DVD_171Micky, reference __SetupInfo.bAngleMarkTime for angle mark display
            OSD_OUTPUT_MACRO ( MSG_ANGLE_CTL, __bAGLN, __SetupInfo.bAngleMarkTime);
        }
        else
        {
            OSD_OUTPUT_MACRO ( MSG_ANGLE_CTL, 0, 0);
        }

    }
#endif  //#ifdef  _DEBUG_ANGLES_NUMBER

    // DVD_171Micky, check angle control for cell
    // only after one NV_INT is got, query angle change UOP
    // if allow angle change, then will display angle information.
    if ( _bAngleCtrlCheck == 1)
    {
        _bAngleCtrlCheck=0;
        if ( NV_QueryUOP ( UOP_CAN_CHANGE_ANGLE ) )
        {
            OSD_OUTPUT_MACRO ( MSG_ANGLE_CTL, __bAGLN, __SetupInfo.bAngleMarkTime);
        }
    }

    // ** TCH0.27; end...
//DVD_031, APS
// the bit 15-14
// 00: APS off
// 01: Type 1
// 10: Type 2
// 11: Type 3
    // DVD_043-1
    // reference APSControl flag
    if (!__SetupInfo.bAPSControl)
    {
        HAL_TVSetAPS( 0 );
    }
    else
    {
        //DVD_045q-1
        // must check APS title
        //Ming0.80, use PCI and DSI directly.
        //HAL_TVSetAPS( _pPCI->PCI_GI.VOBU_CAT[0]>>6);
        //Aron1.07-909, fix the code bug, it should mask bit7~bit2
	HAL_TVSetAPS( (_pPCI->PCI_GI.VOBU_CAT[0] >> 6) & 0x3 );
    }

    //Aron2.37, update start/end of presentation time here.
    __dwVOBU_S_PTM = COMUTL_ReadBufferDWORD ( (char *)&(_pPCI->PCI_GI.VOBU_S_PTM), 0);
    __dwVOBU_E_PTM = COMUTL_ReadBufferDWORD ( (char *)&(_pPCI->PCI_GI.VOBU_E_PTM), 0);

#endif  // #ifndef NO_DVD
}


//****************************************************************************
//  Function    : _CheckVOBUEnd
//  Description : It will monitor whether the cell play to VOBU end/ILVU end
//              : or CELL end
//              :
//  Parameters  : None
//****************************************************************************
BYTE _CheckVOBUEnd()
{
#ifndef NO_DVD
    // Micky1.00, adding resend NV sector mechanism.
    // resend NV sector after NV_INT fail
    // the _bCheckNVData is changed.
    //if (( _bCheckNVData==CELL_WAIT_NV)  // play NV sector, wait for NV_INT
    if (( _bCheckNVData&CELL_WAIT_NV)  // play NV sector, wait for NV_INT
        // DVD_155Micky, enable check NV in linear play mode
        // will switch back to CELL_NORMAL when NV got.
        || (__bCellState == CELL_LINEAR)
        )
    {
        // LLY2.60, must waiting parser complete or time-out first
        // Then, can check if get NV packet
        // Otherwise, we may meet NV packet not ready and go else case
        // Then, parser report complete and NV packet ready now.
        // Notice: can't clear parser complete event flag here
        //         since following flow maybe reference this flag too.
        if( PARSER_QueryEvent( 0,  PARSER_EVENT_COMPLETED, FALSE ) ||
            (OS_GetSysTimer()-_dwTimeNV) > (COUNT_50_MSEC/3))
        {
            if ( PARSER_QueryEvent( 0, PARSER_EVENT_NV_PACK, FALSE ) )
            {
                _bNVRecover=0;

                // LLY2.55, also need to re-correct SCR while NV re-found @ search 1st NV mode
                if( (__bCellState == CELL_SEARCH_1ST_NV) && (_bCheckNVData & CELL_LINEAR_NV) )
                {
                    _bUpdateSCR=TRUE;
                }

                if ( (_bCheckNVData & 0xC0) == 0x80 )
                {
                    DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "NV re-found after NV re-sending\n");
                }

                if(_bCheckNVData & CELL_LINEAR_NV)
                {
                    DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "NV re-found after linear search NV, Sector: %lx\n", __dwVOBUStart);
                }

                // Assing NV state as CELL_GOT_NV, and clear NV search state information
                _bCheckNVData=CELL_GOT_NV;

                // LLY2.32, porting Micky's code for using time map table
                // Micky07312006 begin, for TMAP
                // re-correct SCR value
                if (__bCellState == CELL_LINEAR)
                {
                	_bUpdateSCR = TRUE;
                }
                // Micky07312006 end ...

                // Micky1.02, fix time search forward, will hang at below loop(after total reset)
                // video wait pic size to become positive value
                // but cell wait STC to reach VOBU_E_PTM to send next VOBU
                // need investigate why can't detect 1st video pts
                // must force to update STC before play dedicated VOBU.
                // can remove the force reset STC when the problem is cleared
                if ( _bForceResetSTC )
                {
                    _bForceResetSTC = 0;
                    //Micky0.68, get SCR from DSI
                    //HAL_ReadInfo(HAL_INFO_SCR, &__dw1stSCR);
                    // Ming0.72, change the parameter 2 from __dw1stSCR to __dwTemp);
                    //           If update __dw1stSCR, the show time is wrong in RESUME.
                    //Ming0.80, use PCI and DSI directly.
                    //HAL_CopyDRAM (DSI_GI_BASE, (DWORD)&__dwTemp, 4);
                    //__dwTemp = _pDSI->DSI_GI.NVPCK_SCR;
                    __dwTemp = COMUTL_ReadBufferDWORD ( (char *)&(_pDSI->DSI_GI.NVPCK_SCR), 0);

                    HAL_ControlAVSync(HAL_AVSYNC_RESYNC, __dwTemp);
                }

                // DVD_102Micky, move this before HL command
                // If STC may run to a big value, and exceed the HL end time, the HL won't display
                /*
                // DVD_103Micky, for the case that __dwCellFVOBUSA is not NV pack
                // need update SCR when NV pack is searched. Now no solution
                // Title "The Mummy" 03/01, 02/05
                //if (!__bSTCRunning) //
                */

                // DVD_170Micky, reset STC must be before any Highlight command
                // now HL command is done in DumpNVData-> UpdatePCI.

                // if using __bSTCRunning to check
                // it will cause time search mode keep update SCR
                // we only need to record 1st NV's SCR.
                if (__dwVOBUSA==0)
                {
                    //Micky0.68, get SCR from DSI
                    //HAL_ReadInfo(HAL_INFO_SCR, &__dw1stSCR);
                    //Ming0.80, use PCI and DSI directly.
                    //HAL_CopyDRAM (DSI_GI_BASE, (DWORD)&__dw1stSCR, 4);
                    //__dw1stSCR = _pDSI->DSI_GI.NVPCK_SCR;
                    __dw1stSCR = COMUTL_ReadBufferDWORD ( (char *)&(_pDSI->DSI_GI.NVPCK_SCR), 0);

#ifdef  _DEBUG_STC
                    DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\n1stSCR=%lu", __dw1stSCR);
#endif
                    // Micky0.80a, DISP_NewSTC will be issued to inform STC dis-continue.
                    /*
                    // Micky0.75, if audio remain is 0, reset STC with SCR
                    HAL_ReadInfo(HAL_INFO_AUDIO_REMAIN, &__dwTemp);
                    if (__dwTemp < 0x10)
                    {
                        DISP_NewSTC(__dw1stSCR+1);
                    }
                    */
                    // Micky0.80a, must issue STC disc-continue
#if 1
                    // DVD_103Micky, VOBU_S_PTM= SCR+offset.
                    // actually the value almost the same.
                    // the Mummy SCR value is invalid.(AC3 test)
                    // DVD_102Micky, fix BoneCollector menu will hang after 1/2 hour
                    // if reset STC too early, will cause SP unit can't decode to end
                    // then SP buffer overflow
                    // if STC discontinue or 1st SCR=0
                    //      must reset STC with 1st SCR value, reset SPST
                    // else
                    //      1st SCR > current STC, don't reset STC
                    //      if less, reset STC.
                    //
                    // STC discontinue
                    if ( (__pbi_CELL. C_CAT [0] & 0x20) || (__dw1stSCR == 0) )
                    {
                        // VDD_161Micky, use command to info RISC update STC
                        // fix NF-100 ESD_Boundary, no1/no2 subpicture don't display
                        // set sp-ptm end time as 0, it will terminate current SP.
                        // for bone-collector menu play will hang
                        // the sp_ptm end time is larger than video ?
                        // Micky0.80a, modify parameter
                        DISP_NewSTC(__dw1stSCR+1, TRUE);
                        // Micky1.11f, fix ABex(TDV-545 DEFECT 3051) 1/14, around 5s video display unsmooth
                        // the play command will clear the bit related with display
                        // test nf002 simple seamless playback ok(every 5s STC will reset as 0)
                        /*
                        // for Simple samless playback A/V sync
                        // play command will clear internal PTSs.
                        if (__bModeCmd==KEY_PLAY)
                            W99AV_Command1(COMMAND_PLAY, 0);
                        */
#ifdef  _DEBUG_STC
                        DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nSTC dis-continue, SCR is [%lu]!!", __dw1stSCR);
#endif
                    }
                    else    // STC continue
                    {
                        // DVD_103Micky, on Dinosaur Bonus disc(pilo turn around)
                        // it record STC continue. And the SCR value far larger than current STC(of menu)
                        // if don't update STC, the VOBU will wait until STC reach VOBU_PTM(it nees 7 minutes)
                        // so, next VOBU won't play.(no audio in 31/02)
                        // RISC video PTS sync threshold is 20000
                        // When write a STC that makes it over the threshold, video won't do sync.(free go)
                        // so we reset STC when 1) SCR less than STC(such as prev.chapter)
                        // 2) SCR > (STC+30000)
                        DWORD   dwGap;
                        HAL_ReadInfo(HAL_INFO_STC, &__dwTemp);
                        if (__dw1stSCR >= __dwTemp)
                        {
                            dwGap=__dw1stSCR-__dwTemp;
                        }
                        else
                        {
                            dwGap=0;
                            // Micky2.78b-2, fix Panassonic 8/1 Highlight will display, but soon disappear
                            // the problem is STC free go will be over __dw1stSTC about 3xxx due to too many operation.
                            // RISC will clear DRAM_SP_PTM as 0 when CADR-> 0.
                            // But at that time, new SP just display.
                            // now add threshold, not to update STC all the time.
                            // Use 6000 value is still has chance to go wrong.
                            // Use 10000 as temp.
                            // Micky0.80a, don't issue the new STC info.
                            /*
                            if ( (__dwTemp - __dw1stSCR) >= 10000 )
                            {
                                dwGap = 30000;
                            }
                            */
                        }
                        // Micky2.78b-2, fix Panassonic 8/1 Highlight will display, but soon disappear
                        // add threshold when __dw1stSCR < __dwTemp.
                        //if ( (__dw1stSCR < __dwTemp) || (dwGap>=30000) ) // this is abnormal, still reset STC
                        if ( (dwGap>=30000) )
                        {
                            // set sp-ptm end time as 0, it will terminate current SP.
                            // for bone-collector menu play will hang
                            // the sp_ptm end time is larger than video ?
                            // Micky0.80a, modify parameter
                            DISP_NewSTC(__dw1stSCR+1, TRUE);
                            // Micky1.11f, fix ABex(TDV-545 DEFECT 3051) 1/14, around 5s video display unsmooth
                            // the play command will clear the bit related with display
                            // test nf002 simple seamless playback ok(every 5s STC will reset as 0)
                            /*
                            // play command will clear internal PTSs.
                            if (__bModeCmd==KEY_PLAY)
                                W99AV_Command1(COMMAND_PLAY, 0);
                            */
#ifdef  _DEBUG_STC
                            DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nSTC continue[SCR=%lu], Gap=[%lu]??", __dw1stSCR, dwGap);
#endif
                        }
                        // Micky0.80a, must issue the STC continue info.
                        else
                        {
                            DISP_NewSTC(NULL_0, FALSE);
                        }
                    }
#endif
                }

#ifdef CELL_FORCE_LINEAR_PLAY_TEST
                if(_bLinearNPFFlags & CELL_LINEAR_NPF_RUN)
                {
//#ifdef  DUMP_CELL_INFO
                    //DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "Run in linear mode.");
//#endif
                    __dwCurrentVOBUSA = __dwVOBUSA;
                }
#endif // CELL_FORCE_LINEAR_PLAY_TEST

                _DumpNVData();

#ifdef CELL_FORCE_LINEAR_PLAY_TEST
                if(_bLinearNPFFlags & CELL_LINEAR_NPF_RUN)
                {
                    // Clear NV event.
                    PARSER_QueryEvent( 0, PARSER_EVENT_NV_PACK, TRUE);
                    _bCheckNVData=CELL_NV_NONE;
                    PARSER_Command(0, PARSER_CMD_RESUME, 0);
                    _dwTimeNV = OS_GetSysTimer();
                    goto END_OF_CheckVOBUEnd;
                }
#endif // CELL_FORCE_LINEAR_PLAY_TEST

                // DVD_273.2, for encrpyted DVD bedin
                // it will auto search all cell button commands
                // to find the only one non-NOP command and execute.
                if (__bAutoScans)
                {
                    if (__dwVOBUSA==0)
                    {
                        __bAutoScans--;
                        if (!CELL_QueryStatus(CELL_SCAN_BTN_COMMAND))
                        {
                            __bAutoScans=0;
                        }
                        else
                        {
                            return CELL_LAST_VOBU;
                        }
                    }
                }
                // DVD_273.2, for encrpyted DVD end

                // Micky1.06, fix GoToTime play, it will keep do nv fail<->re-found
                // Fix title Aeroplane Carrier(from mustek), 2/1-> goto 1:20:00 has the problem
                // the __dwCurrentVOBUSA is not set correctly after linear search NV-> NV got.
                // _CellVOBUSearch need correct value to get next NV.
                if ( __bCellState == CELL_SEARCH_1ST_NV )
                    __dwCurrentVOBUSA = __dwVOBUSA;

                // LLY2.32, porting Micky's code for using time map table
                // Micky07312006 begin, for TMAP
                // re-correct SCR value
                if (_bUpdateSCR == TRUE)
                {
                    _bUpdateSCR = FALSE;
                    __dwTemp = CELL_QueryTime();
                    //Aron2.88-909P,Fix ABEX TDV-540CD40 SCB from chapter 17 to chapter 16 then do KEY_PLAY
                    //OSD display abnormal, which is caused by the 1stSCR of cell resided in chapter 16 is updated wrong
                    //Since the orginal method is updated by the value of STC, but the STC is still not updated.
                    //HAL_ReadInfo(HAL_INFO_STC, &__dw1stSCR);
                    {
                        ULONGLONG_UNION u64SCR;
                        //Get the SCR from program stream first to prevent some DSI in NVPCK may have illegal SCR value
                        //If the program stream SCR can't be referenced, we use NVPCK DSI PCR as reference.
                        if(PARSER_MPEG_GetCurrentSCR(&u64SCR))
                        {
                            __dw1stSCR = u64SCR.dw32bit[0];
                            DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "Get __dw1stSCR = 0x%lx from program stream", __dw1stSCR);
                        }
                        else
                        {
                            __dw1stSCR = COMUTL_ReadBufferDWORD ( (char *)&(_pDSI->DSI_GI.NVPCK_SCR), 0);
                            DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "Get __dw1stSCR = 0x%lx from NV PACK", __dw1stSCR);
                        }
                        //DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "__dwTemp = 0x%lx __dw1stSCR = 0x%lx", __dwTemp, __dw1stSCR);
                    }

                    __dw1stSCR /= 90000L;
                    if (__dw1stSCR >= __dwTemp)
                        __dw1stSCR -=__dwTemp;
                    else
                        __dw1stSCR=0;
                    __dw1stSCR*= 90000L;

                    DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "Re-correct __dw1stSCR value=%lu", __dw1stSCR);


                }
                // Micky07312006 end ...

                // LLY2.35, always open following procedure while re-find NV during CELL_LINEAR
                // Since, F/W will set as CELL_LINEAR mode during SRI_TABLE invalid and NV fail
                // And, for SRI_TABLE fail case, we will let it go
//#ifdef  ENHANCE_CELL_ERROR_CONCEAL
                if (__bCellState == CELL_LINEAR)
                {
                    DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "Refind NV during CELL_LINEAR\n");

// LLY2.32, porting Micky's code for using time map table
// Micky07312006 begin, for TMAP
// mark the codes as already done at _bUpdateSCR
#if 0
                    // recover to normal NV
                    // Micky0.87b, fix "The Journey of Man" 1/2, after hang reset, the display time incorrect.
                    // After hang @1:07, reset recover play 1:44 is OK.
                    // The normal play show time 1:04, but slow will show 1:44.
                    // the problem is __dw1stSCR was updated w/ 1:44's SCR.
                    // so we must re-correct the __dw1stSCR value.
                    // the offset between DSI_NV_PCK_SCR and INFO_SCR is about 0.3s.
                    // use INFO_SCR is more simple.

                    __dwTemp = CELL_QueryTime();
    		    	//Micky0.68, get SCR from DSI
                    //HAL_ReadInfo(HAL_INFO_SCR, &__dw1stSCR);
                    //Ming0.80, use PCI and DSI directly.
                    //HAL_CopyDRAM (DSI_GI_BASE, (DWORD)&__dw1stSCR, 4);
                    //__dw1stSCR = _pDSI->DSI_GI.NVPCK_SCR;
                    __dw1stSCR = COMUTL_ReadBufferDWORD ( (char *)&(_pDSI->DSI_GI.NVPCK_SCR), 0);
                    __dw1stSCR /= 90000L;
                    if (__dw1stSCR >= __dwTemp)
                        __dw1stSCR -=__dwTemp;
                    else
                        __dw1stSCR=0;
                    __dw1stSCR*= 90000L;
#ifdef  DUMP_CELL_INFO
                    DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nRe-correct __dw1stSCR value=%lu", __dw1stSCR);
#endif  //#ifdef  DUMP_CELL_INFO
#endif  // #if 0
// Micky07312006 end ...

// Micky0.87. for multi-angle title begin
#ifdef  REFERENCE_SECTOR_ID
                    // DVD_277aMicky, Fix title Aeroplane Carrier(from mustek), 2/3~2/6 NV not found
                    // [28C], send 2064 bytes, parser can see the sector ID.
                    // Need dvdpram.inc code that will update sector ID(+3000h) to PCI_NV_PCK_LBN)
                                    // here will re-calculate __dwVOBUSA/ __dwVOBUStart/ __dwVOBUEnd
                    // can open it till dvdpram.inc is updated
                    // TCC278-2, open this method in 278. Parser code has support this feature from this version.
                    // LLY1.15, remove ATAPI path flow.
                    // read PCI_NV_PCK_LBN, now its value = LBN + 0x30000(by parser)
                    HAL_CopyDRAM (PCI_BASE, (DWORD)__cBuffer, 3*4);
                    __dwTemp=MAKELONG(MAKEWORD(__cBuffer[3],
                             __cBuffer[2]), MAKEWORD(__cBuffer[1],__cBuffer[0]));
                    __dwTemp -= 0x30000;
                    __dwCurrentVOBUSA = __dwVOBUSA = __dwTemp - __dwCellFVOBUSA;
#else  // #ifdef  REFERENCE_SECTOR_ID
                    // Micky0.87. for multi-angle title
                    // use back to DSI, as PCI will be updated by RISC
#ifdef  REDUCE_DSI
                    // DVD_156Micky, add reduce DSI codes
                    //Ming0.80, use PCI and DSI directly.
                    //__dwTemp = _pDSI->DSI_GI.NV_PCK_LBN;
            		__dwTemp = COMUTL_ReadBufferDWORD ( (char *)&(_pDSI->DSI_GI.NV_PCK_LBN), 0);
#else   // #ifndef  REDUCE_DSI
                    // NV_PCK_LBN record the offset to First VOBS.
                    __dwTemp=MAKELONG(MAKEWORD(cDSI.DSI_GI.NV_PCK_LBN[3],
                             cDSI.DSI_GI.NV_PCK_LBN[2]),MAKEWORD(cDSI.DSI_GI.NV_PCK_LBN[1],cDSI.DSI_GI.NV_PCK_LBN[0]));
#endif  // #ifndef  REDUCE_DSI

                    // DVD_155Micky, get current VOBU RLBN from DSI
                    __dwCurrentVOBUSA=__dwVOBUSA=__dwTemp -(__dwCellFVOBUSA-_dwFirst_VOBS);
#endif  // #ifdef  REFERENCE_SECTOR_ID
// Micky0.87. for multi-angle title end

                    __dwVOBUStart=__dwVOBUEnd = __dwCellFVOBUSA + __dwVOBUSA;

#ifdef  DUMP_CELL_INFO
                    DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "NV re-found after linear play, sector: %lx\n", __dwVOBUStart);
#endif  // #ifdef DUMP_CELL_INFO

                    // LLY2.32, clear NV find flag
                    // Notice: suggest to clear it while find it.
                    PARSER_QueryEvent( 0, PARSER_EVENT_NV_PACK, TRUE );

                    // LLY2.32, must read last position before parser stop.
                    __dwTimeNow=UTL_GetCurrentTime () ;
                    //printf("Parser stop: %lx\n", __dwTimeNow);

                    // DVD_170Micky, do NV re-found action when NV INT is found
                    // The NV INT is the latest one for current servo position.
                    _bCheckNVData=CELL_NV_NONE;

                    __dwVOBUEnd=__dwVOBUStart + __dwVOBUEA;

                    // LLY2.32, porting Micky's code to fix Toshiba testing title playback un-smooth issue
                    // Toshiba test title -- begin
                    // After NV-refound, the current finding NV sector is located outside the VOBU range??
                    // just ignore it and go linear mode for re-found NV.
                    if( (__dwVOBUStart < __dwTimeNow) || (__dwVOBUSA>__dwCellLVOBUEA))
                    {
                        __bCellState = CELL_LINEAR;
                        __dwVOBUEnd = __dwCellLVOBUEA;

                        PARSER_Command(0, PARSER_CMD_RESUME, 0);

#ifdef  DUMP_CELL_INFO
                        DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\n[2]Linear %lu-%lu", __dwVOBUStart, __dwVOBUEnd);
#endif  //#ifdef  DUMP_CELL_INFO

                        return VOBU_PLAYING;
                    }
                    // Toshiba test title -- end

    				// Micky0.87, add protection for out of cell range.
                    if ( __dwVOBUEnd > __dwCellLVOBUEA )
                    {
                        __dwVOBUEnd = __dwCellLVOBUEA;
                    }

                    // LLY2.32, call HAL_ControlParser() to stop parser
    				//PARSER_Command(0, PARSER_CMD_STOP, 0);
                    HAL_ControlParser(HAL_PARSER_STOP, 0);
                    SrcFilter_Stop(__dwSFStreamID);
                    PARSER_ActionFilter(0, PARSER_ENABLE_NV_PAUSE, FALSE);

                    // send the remaining VOBU sector for last servo position.
                    __dwVOBUStart=__dwTimeNow+1;
                    __dwTimeBegin = __dwVOBUStart;
                    __dwTimeEnd = __dwVOBUEnd ;
                    // LLY2.35, give start and end time for UTL_PlayFromTime() since the API is updated
                    UTL_PlayFromTime (__dwVOBUStart, __dwTimeEnd) ;

                    // DVD_2.74Micky, fix linear-> NV re-found, video have blocks.
                    __dwVOBUSA += __dwVOBUSRI&0x3fffffff;

                }   // end of linear recover to normal NV mode
//#endif  //#ifdef  ENHANCE_CELL_ERROR_CONCEAL

                // DVD_155Micky, must set cell status as CELL_NORMAL when got NV
                __bCellState = CELL_NORMAL;

                // DVD_100Micky, fix time serach will show chapter time begin
                // don't ref. STC time before time search is done.
                // DVD_171-2Micky, re-define the parameter for _bEnableTimeSearch
                if ( _bEnableTimeSearch==CELL_TIMESEARCH_NONE)
                    __bSTCRunning=TRUE;
            }   // end of NV_INT is checked.
            else
            // NV_INT is not checked begin.
            {
#ifdef CELL_FORCE_LINEAR_PLAY_TEST
                if(_bLinearNPFFlags & CELL_LINEAR_NPF_RUN)
                {
#ifdef  ENHANCE_CELL_ERROR_CONCEAL
                    // Ming0.80, One VOBU should be less than 1 sec.
                    if((OS_GetSysTimer() - _dwTimeNV) > COUNT_1_SEC)
                    {
                        __dwTimeBegin = UTL_GetCurrentTime();
                        HAL_Reset(HAL_RESET_AVSPST);
                        UTL_TransferCommandID(__bModeCmd);
                        if ((__dwTimeBegin + 100) < __dwCellLVOBUEA)
                        {
                            // LLY2.35, give start and end time for UTL_PlayFromTime() since the API is updated
                            UTL_PlayFromTime(__dwTimeBegin+100, __dwTimeEnd);
                            OS_YieldThread();
                            DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "~~~__dwTimeBegin=%lx", __dwTimeBegin);
                            _dwTimeNV = OS_GetSysTimer();
                        }
                        else
                        {
                            return CELL_LAST_VOBU;
                        }
                    }
#endif // #ifdef  ENHANCE_CELL_ERROR_CONCEAL
                    goto END_OF_CheckVOBUEnd;
                }
#endif // CELL_FORCE_LINEAR_PLAY_TEST

                // While NV fail in linear play mode, don't do NV search.
                // will just wait for NV to be re found.
                if (__bCellState != CELL_LINEAR)
                {
                    // LLY2.60, remove following checking to outside
                    // Since, parser complete flag must be checked first
                    // Then, can check if get NV parcket.

                    // LLY1.50, re-adjust the procedure while re-send NV sector
                    // general should receive interrupt immediately.
                    // If can't get NV_INT, and
                    // (1) parser report action done or
                    // (2) NV sector sent done after 50/3 msec
                    // Then, F/W will treat it as NV fail.
                    //if( PARSER_QueryEvent( 0,  PARSER_EVENT_COMPLETED, TRUE ) ||
                    //    (OS_GetSysTimer()-_dwTimeNV) > (COUNT_50_MSEC/3))
                    {
                        //DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "NV parsing complete, spend time: %lx\n", UTL_GetSysTimer()-_dwTimeNV);

                        // Notice: must clear parser complete event flag too.
                        PARSER_QueryEvent( 0,  PARSER_EVENT_COMPLETED, TRUE );

                        // LLY1.50, always parser/ source stop, NV buffer sector action before re-send a NV sector.
                        // ie. don't care if re-send NV or linear search NV.
                        SrcFilter_Stop(__dwSFStreamID);
                        HAL_ControlParser(HAL_PARSER_STOP, 0);
                        PARSER_BufferReset(PARSER_ES_NV);

                        // Micky1.00, adding resend NV sector mechanism.
                        // for CELL_SEARCH_1ST_NV/ CELL_NORMAL only
                        if ( __bCellState != CELL_SKIP_VOBU )
                        {
                            if ( (_bCheckNVData & 0xC0) == 0x40 )   // 1st time NV fail
                            {
                                DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "NV fail, Resend NV Sector %lx", __dwVOBUStart);

                                // NV fail, resend.
                                return VOBU_NEXT;
                            }
                        }

                        // Clear NV search state as none, bit[7:4]
                        _bCheckNVData &= 0x0F;

#ifdef  ENHANCE_CELL_ERROR_CONCEAL
                        // DVD-170Micky, fix NF-100 nonseamless angle change-> scb at boundary
                        // will cause HL disapeear. It's because SP fifo will be reset by HAL_Reset(HAL_RESET_PARSER)
                        // the SP size is not matched with RISC, cause SP error.
                        // must reset NV ( fifo by 0x43, bit 3 control + NV DRAM address.(wait HCT command))
                        // Ming0.80, HAL_RESET_NV do not be implemented now!
                        //HAL_Reset(HAL_RESET_NV);  // need reset NV fifo and NV DRAM address(wait HCT command)
                        // Ming0.80, HAL_PARSER_RESET does not work correct now.
                        //HAL_ControlParser(HAL_PARSER_RESET, 0); // let parser PC reset to beginning

                        // LLY1.50, remove "reset A/V/SP + restore playback command procedure" into VOBU_Skip case only.
                        // Since, the bitstream is continue for 1st NV fail and one by one sector search action
                        // And, the bitstream is dis-continue for other NV fail, and do VOBU skip action.
#if 0
                        // Ming0.80, Must reset all, before searching the next NV_PCK.
                        HAL_Reset(HAL_RESET_AVSPST);
                        UTL_TransferCommandID(__bModeCmd);
#endif  // #if 0

                        // DVD_171Micky, general NV fail (not cell's 1st NV).
                        // will do VOBU skips.
                        if ( __bCellState != CELL_SEARCH_1ST_NV )
                        {
                            // LLY2.32, porting Micky's code to fix some DVD tile root menu can't play end issue
                            // for Harry Potter & Alexander root menu can't play end--begin
                            // Toshiba test title can't play, the recorded NV sector (get from __dwVOBUEA/ _dwVOBUSRI)is incorrect
                            // don't need to do time jump
                            if (UTL_CheckNVErrorCode() != NV_FAIL_BY_READ)
                            {
                                // do linear directly from __dwVOBUSA
                                CELL_LinearPlay();
                                _bNVRecover=0;
                                return VOBU_PLAYING;
                            }
                            // for Harry Potter & Alexander root menu can't play end--end

                            // LLY1.50, remove from each NV re-sending procedure.
                            // Since, the bitstream is continue for 1st NV fail and one by one sector search action
                            // And, the bitstream is dis-continue for other NV fail, and do VOBU skip action.
                            HAL_Reset(HAL_RESET_AVSPST);
                            UTL_TransferCommandID(__bModeCmd);

                            _bNVRecover++;

                            if ( _bNVRecover <= CELL_MAX_SKIP_GAP ) // do VOBU skip
                            {
                                // Micky0.87 begin
                                // before 2nd skip, will do total reset.
                                if (__bAGL_Ns && __bInterleaved)
                                {
                                    if (_bNVRecover>=2)
                                    {
                                        extern BYTE __bFirstPlay;   // Does it play first time ?
                                        //Ming0.80, does not need __dwIER in CT909.
                                        //extern DWORD __dwIER;     // record now IER Value
                                        // wyc1.07, replace H/W reset RISC to soft reset RISC.

                                        //Ming0.80, has reset video in the previous codes
                                        //HAL_Reset(HAL_SOFT_RESET_VIDEO_UPDATE_SEQ);
                                        __bFirstPlay= 3;    // set FirstPlay mode

                                        //Ming0.80, does not need the following codes int CT909.
                                        //W99AV_ClearInterrupt(INT_IFD);
                                        //__dwIER |= INT_IFD;
                                        //W99AV_EnableInterrupt(__dwIER);
                                        //EX1= 1;
#ifdef  DUMP_CELL_INFO
                                        DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nNV-Skip(%lx) fail, force total reset", _bNVRecover);
#endif  //#ifdef  DUMP_CELL_INFO
                                    }
                                }
                                // Micky0.87 end
                                __wTemp = _bSkipGap[_bNVRecover-1]; //get FWDI index
                                __bCellState = CELL_SKIP_VOBU;
#ifdef  DUMP_CELL_INFO
                                DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nNV fail, VOBUSA:(%lx), skip Gap %lx", __dwVOBUSA, __wTemp);
#endif  //#ifdef  DUMP_CELL_INFO
// DVD_156Micky, as reduce DSI codes
#ifdef  REDUCE_DSI
                                // Micky0.87, code reduce begin
                                //__dwTemp = _SearchFWDI((BYTE)__wTemp);
                                //Ming0.80, use PCI and DSI directly.
                                __dwTemp = _SearchFWDI((BYTE)__wTemp);
                                // Micky0.87, code reduce end
#else   //#ifndef  REDUCE_DSI
                                 _bIndex=(__wTemp*4)-1;    //skip 60 seconds
                                __dwTemp= MAKELONG(MAKEWORD(cDSI.VOBU_SRI[_bIndex],
                                            cDSI.VOBU_SRI[_bIndex-1]),
                                            MAKEWORD(cDSI.VOBU_SRI[_bIndex-2],
                                            cDSI.VOBU_SRI[_bIndex-3]));
#endif  //#ifndef  REDUCE_DSI
                                if ((__dwTemp & 0x3fffffff)==0x3fffffff)  // no more VOBU
                                {
                                    // Micky1.24, correct flow should be CELL_LAST_VOBU
                                    /*
                                     __bCellAction = CELL_END;
                                    return CELL_END;
                                    */
                                    return CELL_LAST_VOBU;
                                }
                                // LLY2.05, assign _bNVRecover value as max value to let it go linear playing mode
                                // while the jump offset value is zero
                                // Otherwise, it will trap @ same NV (__dwVOBUSA += __dwTemp&0x3fffffff)
                                else if( (__dwTemp & 0x3fffffff) == 0)
                                {
                                    _bNVRecover = CELL_MAX_SKIP_GAP;
                                    DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "Go linear since jump offset is zero\n");
                                    return VOBU_PLAYING;
                                }

                                if ( _bNVRecover==1 )   // record last DSI VOBUSA
                                    _dwLastVOBUSA = __dwCurrentVOBUSA;
                                //DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "Currnt: %lx, VOBUSA: %lx, __dwTemp: %lx\n",__dwCurrentVOBUSA, __dwVOBUSA, __dwTemp);

                                __dwVOBUSA = _dwLastVOBUSA;
                                __dwVOBUSA+=__dwTemp  & 0x3fffffff;

                                //DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "Jump VOBUSA=%lu", __dwVOBUSA);
                                return  VOBU_NEXT;
                            }   // end of skip gap <= CELL_MAX_SKIP_GAP
                            else
                            // already done MAX_SKIP_GAP1 skips, still fail
                            // just force to linear play mode
                            {
                                // LLY2.32, porting Micky's code to fix some DVD tile root menu can't play end issue
                                // for Harry Potter & Alexander root menu can't play end--begin
                                if ((__dwVOBUSA + 3000) < (__dwCellLVOBUEA-__dwCellFVOBUSA))
                                    __dwVOBUSA+=3000;
                                else
                                {
                                    // Micky2.45, fix time search fail-> auto play next cell will have blocks
                                    // must do A/V reset, as the input NV sector may not be correct, and contain video data
                                    _PGC_BitsDiscontinue ( DISCONTINUE_AV_ONLY );
                                    return CELL_LAST_VOBU;
                                }
                                CELL_LinearPlay();
                                _bNVRecover=0;
                                return VOBU_PLAYING;

                                // mark the codes
#if 0
                                // Micky0.67-909, the flow is for bitstream sent complete and control are same thread
                                // for 909, better control parse to stop for each NV-> then go VOBU_END flow directly.
                                // wait for test.
                                // PARSER_ActionFilter(0, PARSER_ENABLE_NV_PAUSE, TRUE);

                                __bCellState = CELL_LINEAR;
                                // Micky1.21, clear time search when linear mode
                                // to avoid linear->re-found-> will play backward time.
                                _bEnableTimeSearch=CELL_TIMESEARCH_NONE;

                                _bCheckNVData=CELL_NV_NONE;

                                if ((__dwVOBUSA + 3000) < (__dwCellLVOBUEA-__dwCellFVOBUSA))
                                    __dwVOBUSA+=3000;
                                else
                                {
                                    // Micky1.24, correct flow should be CELL_LAST_VOBU
                                /*
                                    __bCellAction = CELL_END;
                                    return CELL_END;
                                */
                                    return CELL_LAST_VOBU;
                                }

                                __dwVOBUStart=__dwCellFVOBUSA + __dwVOBUSA;
                                __dwVOBUEnd=__dwCellLVOBUEA;
#ifdef  DUMP_CELL_INFO
                                DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nLinear %lu-%lu", __dwVOBUStart, __dwVOBUEnd);
#endif  //#ifdef  DUMP_CELL_INFO
                                // TCC278
                                __dwTimeBegin = __dwVOBUStart;
                                __dwTimeEnd = __dwVOBUEnd ;

                                // LLY2.35, give start and end time for UTL_PlayFromTime() since the API is updated
                                UTL_PlayFromTime (__dwVOBUStart, __dwTimeEnd) ;
                                //SERVO_ReadSectors(__dwVOBUStart, __dwVOBUEnd);
                                __dwTimeNow = __dwVOBUStart;
                                return VOBU_PLAYING;
#endif
                                // for Harry Potter & Alexander root menu can't play end--end
                            }   // end of force linear play
                        }   // end of CELL_NORMAL
                        else    //DVD_171Micky, NV fail when CELLStatus=CELL_SEARCH_1ST_NV
                        // NV fail when ENHANCE_CELL_ERROR_CONCEAL is not defined.
                        // will do linear search NV
                        {
                            // Micky1.00, adding resend NV sector mechanism.
                            // when linear serach 1st NV mode, don't resend NV sector when fail
                            _bCheckNVData |= CELL_LINEAR_NV;
// Micky0.87. for multi-angle title begin
#ifdef  REFERENCE_SECTOR_ID
                            // DVD_277aMicky, Fix title Aeroplane Carrier(from mustek), 2/3~2/6 NV not found
                            // The title PCI/DSI_NV_PCK_LBN value is recorded incorrectly from sector 192042
                            // 28C/ 28ATAPI, use different method
                            // [28ATAPI], send 2048 bytes, parser can't see the sector ID
                            // 1st NV not found-> sector by sector search till NV found, __dwVOBUSA= sector ID-__dwCellFVOBUSA
                            // the value is correct for the title "Aeroplane Carrier"
                            // [28C], send 2064 bytes, parser can see the sector ID.
                            // Need dvdpram.inc code that will update sector ID(+3000h) to PCI_NV_PCK_LBN)
                            // 1st NV not found-> Linear play till NV re-found
                            // can open it till dvdpram.inc is updated
                            // TCC278-2, open this method in 278. Parser code has support this feature from this version.
                            // LLY1.15, always go Servo interface flow while enable #define REFERENCE_SECTOR_ID
                            __bCellState = CELL_LINEAR;

                            // LLY2.32, ask parser to stop while finding NV sector
                            // Notice: only enable it while linear play mode
                            //         and must clear it while NV re-find case.
                            PARSER_ActionFilter(0, PARSER_ENABLE_NV_PAUSE, TRUE);

                            // Micky1.21, clear time search when linear mode
                            // to avoid linear->re-found-> will play backward time.
                            _bEnableTimeSearch=CELL_TIMESEARCH_NONE;

                            _bCheckNVData=CELL_NV_NONE;

                            __dwVOBUStart=__dwCellFVOBUSA + __dwVOBUSA;
                            __dwVOBUEnd=__dwCellLVOBUEA;
                            // TCC278-2, from 2.78, will call UTL_PlayFromTime instead of SERVO_ReadSectors.
                            // to cover the mini-DVD issue.
                            //SERVO_ReadSectors(__dwVOBUStart, __dwVOBUEnd);
                            __dwTimeBegin = __dwVOBUStart;
                            __dwTimeEnd = __dwVOBUEnd ;
                            // LLY2.35, give start and end time for UTL_PlayFromTime() since the API is updated
                            UTL_PlayFromTime (__dwVOBUStart, __dwTimeEnd) ;
                            __dwTimeNow = __dwVOBUStart;

#ifdef  DUMP_CELL_INFO
                            DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\n[3]Linear %lu-%lu", __dwVOBUStart, __dwVOBUEnd);
#endif  // #ifdef DUMP_CELL_INFO

                            return VOBU_PLAYING;
#else   // #ifdef REFERENCE_SECTOR_ID
                            // Micky0.87. for multi-angle title end

                            __dwVOBUSA++;

#ifdef  DUMP_CELL_INFO
                            DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "Linear Search NV :%lx", __dwVOBUStart);
#endif  // #ifdef DUMP_CELL_INFO

                            // force to key next if can't find NV.
                            if (__dwVOBUSA >= 1000 )
                            {
#ifdef  DUMP_CELL_INFO
                                DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nLinear Search 1st NV fail(1000), force play next");
#endif  //#ifdef  DUMP_CELL_INFO
                                __bFWKey = KEY_NEXT;
                            }
                            return  VOBU_NEXT;
#endif  // #ifdef  REFERENCE_SECTOR_ID
                        }   // end of linear search NV
#endif  //#ifdef  ENHANCE_CELL_ERROR_CONCEAL
                    }   // end of NV_INT is not checked over time out value.
                }   // end of __bCellState != CELL_LINEAR
            }
        // NV_INT is not checked end.
        }

        // DVD_171Micky, the tolerance time for waiting NV_INT is 50ms/3
        // when NV_INT is not got within this period, just keep waiting.
        if ( _bCheckNVData != CELL_GOT_NV )
        {
            // linear play mode, when NV_INT is not checked
            // still need check VOBU range end.
            if ( __bCellState != CELL_LINEAR )
                return VOBU_PLAYING;
        }

    }   // end of checking NV_INT.

#ifdef CELL_FORCE_LINEAR_PLAY_TEST
END_OF_CheckVOBUEnd:
#endif // CELL_FORCE_LINEAR_PLAY_TEST

    if ( PARSER_QueryEvent( 0,  PARSER_EVENT_COMPLETED, FALSE ) )
    {
    	// Micky0.66-909. clear bitstream sending complete flag
        PARSER_QueryEvent( 0,  PARSER_EVENT_COMPLETED, TRUE );
        if (__bInterleaved)
        {
            if (__dwVOBUEnd >= __dwILVUEnd)
            {
                return ILVU_END;
            }
            else
                return VOBU_END;
        }
        else
        {
            return VOBU_END;
        }
    }

#endif  //#ifndef NO_DVD

    return VOBU_PLAYING;
}
//**********************************************************************
//  Function    : CELL_AngleChange
//  Description : Whenever an different angle is changed it's called,
//              : need get the destination adress for new angle(NSML_AGL_C)
//  Parameters  : bAngle, angle number
//  Output      : __bAngleChange=TRUE, for SML_AGL change
//              : __dwVOBUSA is changed, for NSML_AGL change
//**********************************************************************
void CELL_AngleChange(BYTE bAngle)
{
#ifndef NO_DVD
    __bAngle=bAngle;
    //DVD_042-1
    __bAngleChange=TRUE;

// DVD_100bMicky, fix Train View Zone 1, using left/right highlight to change angle
// won't call MSG_ANGLE, so when OSD display is off, can't see angle update OSD
    if ( __bAGL_Ns )
    {
        // DVD_171Micky, reference __SetupInfo.bAngleMarkTime for angle mark display
        OSD_OUTPUT_MACRO ( MSG_ANGLE_CTL, __bAGLN, __SetupInfo.bAngleMarkTime);
    }
#endif  //#ifndef NO_DVD
}
//**********************************************************************
//  Function    : _UpdatePCI
//  Description : Update the PCI info.
//              : It will read the PCI info. from DRAM
//  Parameters  :
//**********************************************************************
void _UpdatePCI(void)
{
#ifndef NO_DVD
    BYTE    bHLStatus;
    WORD    wTemp;
    BYTE    bTemp;

    //Ming0.80, use PCI and DSI directly.
    __pHLIBuffer = (volatile PHLI)&_pPCI->HLI;

    //Ming0.80, use PCI and DSI directly.
    bHLStatus = _pPCI->HLI.HLI_GI.HLI_SS[1] & 0x03;

    // Micky1.06, fix the "Best Of Forever Love Songs" can't use number selection
    // the 1st PCI information encode same highlight information.
    // so must process 1st "same highlight information" of cell
    if (bHLStatus == 0x02)  // same highlight information
    {
        if ( __bBTN_Ns== 0)
            bHLStatus = 1;
    }

    // the button selection end time
    //DVD_039-1
    if (bHLStatus==1)
    {
        BYTE    _bMask;
//DVD_039-1, Choose High Light Group
        //Ming0.80, use PCI and DSI directly.
        //wTemp = _pPCI->HLI.HLI_GI.BTN_MD;
	wTemp = COMUTL_ReadBufferWORD ( (char *)&(_pPCI->HLI.HLI_GI.BTN_MD), 0);

// DVD_103Micky, reference __bSPST_Display_Mode and __bSPST_LB only
        if ( (__bSPST_Display_Mode==1) && (__bSPST_LB))
        {
            _bMask=0x02;    // LB
        }
        else
        if (__bSPST_Display_Mode==0)
        {
            _bMask=0x04;    // PS
        }
        else
            _bMask=0x01;    // WIDE

        for (_bIndex=0;_bIndex<(wTemp & 0x3000)>>12;_bIndex++)
        {
            bTemp=(BYTE)(wTemp >> (2-_bIndex)*4) & 0x07;
            if (bTemp & _bMask)
            {
                // found the group that contain PanScan HL
                _bIndex |=0x80;
                break;
            }
        }

        if (_bIndex&0x80)
        {
            _bIndex &=0x3f;
        }
        else
            _bIndex=0;

        switch(_bIndex)
        {
            case    0:  // group 0
                    // Micky0.83, modify the group start value to be constant
                    // the constant will reference W99AV_ADDR_NVBUF
                    // write the bytes position
                    // 1 group/ 2 groups, each 18 buttons/ 3 groups, each 12 buttons
                    _CELL_SetBTNGroup(0, 1);
                    //W99AV_WriteDRAMData(W99AV_DRAM_BUTTON_INFO_START, (W99AV_ADDR_NVBUFF*4L)+0x8EL);
                    break;
            case    1:  // group 1
                    if ( ((wTemp & 0x3000)>>12) ==2 ) // group1 of 2 groups
                    {
                        //W99AV_WriteDRAMData(W99AV_DRAM_BUTTON_INFO_START, (W99AV_ADDR_NVBUFF*4L)+ 0x8EL + 18*18L);
                        _CELL_SetBTNGroup(1, 2);
                    }
                    else    // group 1 of 3 groups
                    {
                        //W99AV_WriteDRAMData(W99AV_DRAM_BUTTON_INFO_START, (W99AV_ADDR_NVBUFF*4L) + 0x8EL + 18*12L);
                        _CELL_SetBTNGroup(1, 3);
                    }
                    break;
            case    2:  // group 2 of 3 groups
                    //W99AV_WriteDRAMData(W99AV_DRAM_BUTTON_INFO_START, (W99AV_ADDR_NVBUFF*4L) + 0x8EL + 18*24L);
                    _CELL_SetBTNGroup(2, 3);
                    break;
        }

        // highlight start time
        //Ming0.80, use PCI and DSI directly.
#ifdef _CELL_INFO
        DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nHLI start time=0x%08lx", _pPCI->HLI.HLI_GI.HLI_S_PTM);
#endif
        // highlight end time
        //Ming0.80, use PCI and DSI directly.
#ifdef _CELL_INFO
        DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nHLI end time=0x%08lx", _pPCI->HLI.HLI_GI.HLI_E_PTM);
#endif

        // selection end time
        // 0xffffffff means Button selection is used during cell still
        //Ming0.80, use PCI and DSI directly.
//        __dwBTNSelEndTime = _pPCI->HLI.HLI_GI.BTN_SL_E_PTM;
	__dwBTNSelEndTime = COMUTL_ReadBufferDWORD ( (char *)&(_pPCI->HLI.HLI_GI.BTN_SL_E_PTM), 0);

#ifdef _CELL_INFO
        DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nBTN selection end time=0x%08lx", __dwBTNSelEndTime);
//        DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nButton Selection time=%lu(sec)", (__dwBTNSelEndTime-__dwHLStartTime)/90000);
#endif

        // base offset for button
        //Ming0.80, use PCI and DSI directly.
        __bBTNBaseOffset = _pPCI->HLI.HLI_GI.BTN_OFN;
#ifdef _CELL_INFO
        DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nBTN base Offset=%d", __bBTNBaseOffset);
#endif

        //???
        // number of buttons
        //Ming0.80, use PCI and DSI directly.
        __bBTN_Ns = _pPCI->HLI.HLI_GI.BTN_Ns & 0x3f;
//DVD_038HLBTN
//the end button offset should reference __bSELBTN_Ns
//        __bBTNEndOffset = __bBTNBaseOffset+__bBTN_Ns;
#ifdef _CELL_INFO
        DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nValid buttons=%d", __bBTN_Ns);
#endif

        // number of selectable buttons
        //Ming0.80, use PCI and DSI directly.
        __bSELBTN_Ns = _pPCI->HLI.HLI_GI.NSL_BTN_Ns & 0x3f;

// DVD_160Micky, fix "500 & China Blue"(summer night wind), can use number select(from 1.61)
// support number selection for invalid encode button info.(BaseOffset=17, SELBTN_Ns=0)
// menu show 17 #
// But for "Phil Chang", Rain keeps falling, still can't use number select.
// (__bBTNBaseOffset and __bSELBTN_Ns are all 0, BTN_Ns=15, menu show 12 number)
// define this will support number select for all buttons
// will cause the problem that when the number is not start from 1
// such as Phil Chang song index-> next menu(#13~#25)
#ifdef  SUPPORT_LOOSE_BUTTON_CONTROL
        if ( !__bSELBTN_Ns )
        {
            __bSELBTN_Ns = __bBTN_Ns;//__bBTNBaseOffset;
            __bBTNBaseOffset=0;
#ifdef  _DEBUG_INFO
#ifdef    SUPPORT_PRINTF
            DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nForce SELBTN_Ns=%d", __bSELBTN_Ns);
#endif
#endif
        }
#endif

//DVD_050aMicky
// PCI data protection
// select button Ns <= BTN Ns.(VI4-120)
        if (__bSELBTN_Ns > __bBTN_Ns)
            __bSELBTN_Ns=0;

//DVD_038HLBTN
//the end button offset should reference __bSELBTN_Ns
        __bBTNEndOffset = __bBTNBaseOffset+__bSELBTN_Ns;
#ifdef _CELL_INFO
        DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nSelectable buttons=%d", __bSELBTN_Ns);
#endif

        // default highlight button number
        // must highlight the default button when reach the time HLI_S_PTM
        // ???
        //Ming0.80, use PCI and DSI directly.
        __bDefaultHL_BTNN = _pPCI->HLI.HLI_GI.FOSL_BTNN & 0x3f;
//DVD_039-1
// according to the spec, the value could be 0~36(1 grp), 0~18(2 grp), 0~12(3 grp)
// for the title Phil Chang(049) The rain keeps falling
// the __bBTN_Ns=16, but __bDefaultHL_BTNN is 56?
        if (__bDefaultHL_BTNN > __bBTN_Ns)
            __bDefaultHL_BTNN=__bBTN_Ns;

        if (__bDefaultHL_BTNN)
        {
            //VI-166
            //a) FOSL_BTNN is set, assign to SPRMs[8]
            __bNowBTNNumber=__bDefaultHL_BTNN;  //question point
            // clear bit 10-15
            __wSPRMs [8]&=0x03ff;
            __wSPRMs [8]|=(WORD)(__bDefaultHL_BTNN) << 10;
//            DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nDefault highlight BTN=%d", __bDefaultHL_BTNN);
        }
        else
//        if (__bDefaultHL_BTNN==0)
        {
            // no default highlight button number
            // must reference __wSPRMs (8)
            // Ref. VI4-166
            BYTE    bHL_BTNN;

//            DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nNo default highlight BTN");
            // bits 10-15
            bHL_BTNN=(BYTE)(__wSPRMs [8]>>10);
//DVD_038HLBTNN
            //b-1
            // current value SPRMs[8] < number of buttons
            // don't update SPRM[8].
            //b-2
            // current value SPRMs[8] > number of buttons
            // set to the largest BTNN
//DVD_038HLBTN
// it destroys the rule b-1
/*
//DVD_037DEFAULT_SELECTION
            if (bHL_BTNN == 0)
                bHL_BTNN = __bBTNBaseOffset+1;
*/

//DVD_038.2HLBTN-2
// for the title Life is beautiful, KEY_MENU at TT/CC 2/1,2,3,4
// the SPRMs[8] value will be 0.
            if ( (bHL_BTNN > __bBTN_Ns) || (bHL_BTNN==0) )
            {
                //DVD_099Micky, when SPRMs[8]=0, set as 1st BTNN
                // for title The Life Is Beautiful & River Dance
                /*
                // set the __wSPRMs 8 as largest BTNN
                bHL_BTNN=__bBTN_Ns;
                */
                bHL_BTNN=1;
                // clear bit 10-15
                __wSPRMs [8]&=0x03ff;
                __wSPRMs [8]|=(WORD)(bHL_BTNN) << 10;
            }

            __bNowBTNNumber=bHL_BTNN;       //question point
//            DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nDefault highlight BTN=%d(By __wSPRMs 8)", __bDefaultHL_BTNN);
        }
//DVD029_Highlight
        HAL_ControlHighlight(HAL_HLI_ACTION_SELECT, __bNowBTNNumber + __bGroupOffset);

        // the buttun number is forced to active when reach BTN selection end time
        //Ming0.80, use PCI and DSI directly.
        __bForceActiveBTNN = _pPCI->HLI.HLI_GI.FOAC_BTNN & 0x3f;
//DVD_039-1
// for the title Phil Chang(049) The rain keeps falling
// the __bBTN_Ns=16, but __bForceActiveBTNN is 57?
        if ( (__bForceActiveBTNN > __bBTN_Ns) && (__bForceActiveBTNN != 0x3f) )
//DVD_050aMicky
// PCI data protection
// when force active button out of range, just ignore it.
// Mustek doing the same(no active)
// yamaha & S/W DVD active as last button.
//            __bForceActiveBTNN=__bBTN_Ns;
            __bForceActiveBTNN=0;

        //Aron2.36, If the number of Button groups is 0, the __bForceActiveBTNN should be treated as "does not exist"
        //Scratch%40 DVD title made by J500. AV hangs.It is caused by invalid nv data, the button selection time out is too big to wait.
        //Skip the waiting while there is no button group.
        wTemp = COMUTL_ReadBufferWORD ( (char *)&(_pPCI->HLI.HLI_GI.BTN_MD), 0);
        if ((wTemp & 0x300) == 0)
        {
            __bForceActiveBTNN = 0;
        }


#ifdef  _CELL_INFO
        if (__bForceActiveBTNN==0)
            DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nNo force active BTN");
        else
            DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nForce active BTN=%d", __bForceActiveBTNN);
#endif
        // DVD_160Micky
        // reference VI3-66, once transferred to Action state, any transfer shall not allowed
        if (__bBTN_Ns)
        {
            _bButtonState = CELL_BUTTON_SELECTION;
#ifdef  _DEBUG_BUTTON_STATE
#ifdef  SUPPORT_PRINTF
            DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nButtonState ==> SELECTION");
#endif
#endif
        }
    }
#endif  // #ifndef NO_DVD
}


//**********************************************************************
//  Function    : _ActiveButton
//  Description : 1. Called when user press enter for a selection
//              : 2. Called when default selection to active
//  Parameters  : None
//  return      : TRUE, action button is valid
//              : FALSE, action button is invalid
//              : __sNVCommand must contain 8 bytes command string
//**********************************************************************
BYTE _ActiveButton(void)
{
#ifndef NO_DVD
    // no button is selected
    if (__bNowBTNNumber==0)
        return FALSE;

    //Ming0.80, use PCI and DSI directly.
    // Do not need _UpdateBTNInfo().
    // Micky2.31, reduce codes, add API _UpdateBTNInfo()
//    _UpdateBTNInfo(__bNowBTNNumber);
    _pBTNInfo = (PCI_BTNIT *)&_pPCI->HLI.BTNIT[__bNowBTNNumber-1];

    NV_ExecuteCommand ((*_pBTNInfo).BTN_CMD);

    //DVD_050Micky
    // fix the NF-002, set tmp parental control
    // on VI3-34, table 3.3.6.4-1
    // shall release still when button active
    __bStillTime= 0;

    // DVD_099dMicky, Fix Menu-> select will show a large time first
    // clear STCRunning flag
    // is it possible button select(do nothing)- UTL_OutputShowTime show 0-> until next NV
    // UTL_OutputShowTime will do protection
    __bSTCRunning=FALSE;

    // DVD_160Micky, fix button active, but still can do button control
    // reference VI3-66, once transferred to Action state, any transfer shall not allowed
    _bButtonState = CELL_BUTTON_ACTION;
#ifdef  _DEBUG_BUTTON_STATE
#ifdef  SUPPORT_PRINTF
    DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nButtonState ==> ACTION");
#endif
#endif

#endif  //#ifndef NO_DVD
    return TRUE;
}
//**********************************************************************
//  Function    : CELL_QueryUOP
//  Description : Query the capability of UOP of each VOBU
//              : UOP 3 to 16, 18 to 24
//  Parameters  : dwQuery, UOP bit query
//  return      : TRUE, dwQuery UOP is allowed
//              : FALSE, dwQuery UOP is prohibited
//**********************************************************************
BYTE CELL_QueryUOP(DWORD  dwQuery, WORD *wParam)
{
#ifndef NO_DVD

//Aron1.08-909, Start
//Modified the CELL_QueryUOP to fix DVD Forum NF-250
//TT/CC: 07/14 press KEY_PAUSE during time 2:18:xx ~ 2:19:xx ==> Pause key should be
//prohibited during time 2:10 ~ 2:20.

    DWORD dUOPCTRL = 0;
    BYTE bIndex;

    //Aron2.33, this means no NV is loaded, allow the UOP?
    if(_pPCI != (void *)PCI_BASE)
    	return TRUE;

    HAL_ReadInfo(HAL_INFO_STC, &__dwTemp);

    //Aron1.08-909, set current NV's UOP as default when the belowing search fail
    //dUOPCTRL = _pPCI->PCI_GI.VOBU_UOP_CTL;
    dUOPCTRL = COMUTL_ReadBufferDWORD ( (char *)&(_pPCI->PCI_GI.VOBU_UOP_CTL), 0);

    for(bIndex = 0; bIndex<PAST_NV_RING_BUFF_SIZE; bIndex++)
    {
        //Aron1.08-909, V14-108. The User Operation control is valid from the
        // time specified by VOBU_S_PTM upto the time specified by VOBU_E_PTM
        if ( (__dwTemp > _past_NV_UOPs[bIndex].VOBU_S_PTM) &&
             (__dwTemp < _past_NV_UOPs[bIndex].VOBU_E_PTM) )
            dUOPCTRL = _past_NV_UOPs[bIndex].VOBU_UOP_CTL;
    }
//Aron1.08-909, End

    // Ref. VI4-108
    // Ref. VIX-62(appendix)
    // bit =1 means prohibited
    // bit =0 means permitted

    // DVD_099Micky, UOP query
    if ( dwQuery & (UOP_CAN_FORWARD_SCAN | UOP_CAN_BACKWARD_SCAN) )
    {
        if (__bVOBUStill)
        {
            __bVOBUStill=FALSE; //???, but should enter scan???
        }

        // now don't allow scan in still mode
        // But ref VI3-34,3.3.6.4-1 table, scf/scb should clear cell still

        // DVD-170Micky. should reference __pbi directly for cell still ??
        // for NF-100, non-seamless angle chage-> SCB at boundary
        // it will enter SCB mode for a menu.
        // but when stay at menu, it won't allow scf(disabled by still time=0xff)
        // so maybe can pre-check cell still time, disallow scan action.
        // this can only solve CELL still, how about PGC still?
//        if ( __bStillTime==0xff)
        if ( (BYTE)(__pbi_CELL. C_CAT [2])==0xff)
            return FALSE;

        // ref. VI 3-50, Access Restriction > VOBU or PGC UOP_CTL
        // must check Access Restriction Flag(within C_PCI) for scan for/backward
        // Access Restriction Flag is on
        if ( __pbi_CELL. C_CAT [1] & 0x20 )
            return FALSE;
    }
    if ( dwQuery & UOP_CAN_PAUSE_ON )
    {
        if (__bStillTime || __bVOBUStill)
            return FALSE;
    }

    //Ming0.80, use PCI and DSI directly.
//    HAL_CopyDRAM (PCI_VOBU_UOP_CTL, (DWORD)__cBuffer, 1*4);
//    if ( _ReadBufferDWORD(__cBuffer, 0) & dwQuery )
    if ( dUOPCTRL & dwQuery )
        return FALSE;
    else
        return TRUE;

#endif  //#ifndef NO_DVD
    return FALSE;
}
//**********************************************************************
//  Function    :
//  Description : It will set the Cell start/end
//              :
//  Parameters  :
//  return      :   0, Invalid button move
//              :   1, Button active, need execute button command
//              :   2, Encounter an auto action button, need execute button command
//**********************************************************************
BYTE CELL_ButtonControl(BYTE bDirection, BYTE bState)
{
#ifndef NO_DVD
    BYTE    bBTNNumber;

    // DVD_160Micky, fix button active, but still can do button control
    // reference VI3-66, once transferred to Action state, any transfer shall not allowed
    if (_bButtonState != CELL_BUTTON_SELECTION)
    {
#ifdef  _DEBUG_BUTTON_STATE
#ifdef  SUPPORT_PRINTF
    DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nNot in button selection state");
#endif
#endif
        return FALSE;
    }

//DVD_039-1, Disable Button control
    if (!__bBTN_Ns)
        return FALSE;

    // the bDirection must be 0~67
    switch(bDirection)
    {
        // these ID define must by this sequence(up/down/left/right)
        case    HAL_HLI_BUTTON_UPPER:
        case    HAL_HLI_BUTTON_DOWN:
        case    HAL_HLI_BUTTON_LEFT:
        case    HAL_HLI_BUTTON_RIGHT:
        // bDirection=0, Upper
        // bDirection=1, Lower
        // bDirection=2, Left
        // bDirection=3, Right

                //DVD_046-1
                // only left/right/upper/down need button information
                // !!! whenever __bNowBTNNumber is changed, need re-ead these information
                // Micky2.31, reduce codes, add API _UpdateBTNInfo()
                //Ming0.80, use PCI and DSI directly.
                // Do not need _UpdateBTNInfo().
                //_UpdateBTNInfo(__bNowBTNNumber);
                _pBTNInfo = (PCI_BTNIT *)&_pPCI->HLI.BTNIT[__bNowBTNNumber-1];

        // bDirection=4, highlight the __bNowBTNNumber
                if (__bNowBTNNumber==0) // no button is selected
                    return FALSE;
                // the button number for the position
//DVD_036
//DVD_038HLBTN, the __bNowBTNNumber is always in the range 1~__bBTN_Ns
//DVD_045
//                bBTNNumber=cPCI.HLI.BTNIT[__bNowBTNNumber-1].AJBTN_POSI[bDirection-HAL_HLI_BUTTON_UPPER]&0x3f;
                bBTNNumber=(*_pBTNInfo).AJBTN_POSI[bDirection-HAL_HLI_BUTTON_UPPER]&0x3f;
                //DVD_050aMicky
                //Use valid PCI/DSI data
                // the button number can't be 0
                if ( !bBTNNumber || (bBTNNumber > __bBTN_Ns) )
                    return FALSE;

                if (bBTNNumber==__bNowBTNNumber)
                    return FALSE;   // no button for the direction
#ifdef  _CELL_INFO
//                DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nNew BTN number=%d", bBTNNumber);
#endif
                __bNowBTNNumber=bBTNNumber;
                // clear bits 10-15
                __wSPRMs [8]&=0x03ff;
                __wSPRMs [8]|=(WORD)(__bNowBTNNumber) << 10;
//DVD_036
                HAL_ControlHighlight(HAL_HLI_ACTION_SELECT, __bNowBTNNumber+__bGroupOffset);
// reference VI4-128 for auto action 00->has auto selection/action
// the spec. wrong???
//DVD_038HLBTN, the __bNowBTNNumber is always in the range 1~__bBTN_Ns

                //DVD_046-1
                // only left/right/upper/down need button information
                // !!! whenever __bNowBTNNumber is changed, need re-ead these information
                // Micky2.31, reduce codes, add API _UpdateBTNInfo()
                //Ming0.80, use PCI and DSI directly.
                // Do not need _UpdateBTNInfo().
                //_UpdateBTNInfo(__bNowBTNNumber);
                _pBTNInfo = (PCI_BTNIT *)&_pPCI->HLI.BTNIT[__bNowBTNNumber-1];

                if ( ((*_pBTNInfo).BTN_POSI[3]&0xC0) == 0x40 )
                // no selection state
                {
#ifdef  _CELL_INFO
                    DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nAuto action");
#endif
                    // must execute the Button command immediately
//DVD_036
// other player keep as selection color??
                    //DVD_042-1
                    // set as active color when auto action.
                    HAL_ControlHighlight(HAL_HLI_ACTION_ACTIVE, __bNowBTNNumber+__bGroupOffset);
                    _ActiveButton();
                    return 2;   // inform navigator need execute the button command
                }
                return 1;
                break;
        default:
                // 0~63
                switch(bState)
                {
                    case    HAL_HLI_ACTION_SELECT:
                            // select a number
                    case    HAL_HLI_ACTION_ACTIVE:
                            //DVD_039-1
                            // only allow to call these 2 interface though number selection
                            // active a number
                            //DVD_038HLBTN
                            // VI 4-120
                            // selectable BTN=0, means don't allbowed using Number select
                            if (!__bSELBTN_Ns)
                                return FALSE;

//DVD_039-1
// the caller must use button number by __bBTNBaseOffset base.
                            // Micky0.91, fix the byte-> dword error.
                            // when 32bits, the (BYTE + constant) will be processed by DWORD.
                            // when the value is 0xFF, the value will become 0x0100.
                            if ( ( bDirection < (BYTE)(__bBTNBaseOffset+1) ) ||
                                 ( bDirection > __bBTNEndOffset) )
                                return FALSE;
                                //DVD_038HLBTN
                            __bNowBTNNumber=bDirection-__bBTNBaseOffset;
                            // clear bits 10-15
                            __wSPRMs [8]&=0x03ff;
                            __wSPRMs [8]|=(WORD)(__bNowBTNNumber) << 10;
                            HAL_ControlHighlight(bState, __bNowBTNNumber + __bGroupOffset);
                            _ActiveButton();
                            return 1;
                    case    HAL_HLI_ACTION_ENTER:
                            HAL_ControlHighlight(HAL_HLI_ACTION_ENTER, __bNowBTNNumber + __bGroupOffset);
                            _ActiveButton();
                            return 1;
                }

    }
#endif
    return FALSE;
}
//**********************************************************************
//  Function    :
//  Description : It will set the Cell start/end
//              :
//  Parameters  :
//              :
//**********************************************************************
//#define DEBUG_SCAN_ACTION
// LLY2.36a, modify the scan jump procedure to let it can return to main flow
// while waiting to issue next scan command.
BYTE CELL_ScanJump(void)
{
#ifndef NO_DVD
    // Indicate if start to next jump action.
    BYTE    bStartJump;

    // Always initial the start jump flag as FALSE
    bStartJump=FALSE;
    switch(__bScan)
    {
    case    SCAN_INIT:
    case    SCAN_GO:

        // Enable the start jump flag to process next jump action, while SCAN status are
        // [1] SCAN_INIT: receive SCAN key
        // [2] SCA_GO: SCAN CMD has been done & SCAN_DONE flag has got
        if(__bScan == SCAN_INIT)
        {
            bStartJump=TRUE;

#ifdef  DEBUG_SCAN_ACTION
            DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "SCAN initial\n");
#endif  // #ifdef DEBUG_SCAN_ACTION
        }
        else if(__bScan == SCAN_GO)
        {
        	HAL_ReadInfo(HAL_INFO_DECCMD_ACK, &__dwTemp);
        	if ( __dwTemp == MODE_SCAN_DONE )
        	{

#ifdef  DEBUG_SCAN_ACTION
                DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "Scan Done\n");
#endif  // #ifdef DEBUG_SCAN_ACTION

                bStartJump = TRUE;

                // Keep current time for SCAN mode each frame display period control
                __dwScanTime = OS_GetSysTimer();
        	}
        }

        // Process next jump action, ex.
        // [1] Stop decoder, parser, source
        // [2] Reset buffer
        // [3] Calculate the next jump position
        if(bStartJump)
        {
            // Set the SCAN status as SCAN_END if SCAN_DONE
            __bScan = SCAN_END;

            //Micky1.10-909, force __dwVOBUEA =0 to prevent NF-250,
            //Title menu-> Angle Test-> select seamless or non-seamless angle change->
            //after notmla play to 11s-> SCBx2->it will hang when play to 00:10:02.
            __dwVOBUEA =0;
            // Freeze STC value while SCAN_DONE
            // Otherwise, STC value will be reset to zero after decoder receiving STOP command.
            // So, we can see 0:00:00 during SCAN --> NPF moment.
            // Notice: must delay 50msec to waiting STC update done.
            OS_DelayTime(COUNT_50_MSEC);//, FALSE);
            HAL_ReadInfo(HAL_INFO_STC, &__dwSTCValue);

            // LLY1.20, freeze the STC forever here,
            // Since, STC maybe un-freeze immediately while SCAN_INIT to SCAN
            // And, issue freeze STC to waiting next STC after issue stop command.
            // Otherwise, nobody to release the STC
            //DISP_STCFreeze(__dwTemp, DISP_WAIT_NEXT_STC);
            DISP_STCFreeze(__dwSTCValue, DISP_FORCE_FREEZE_STC);

#ifdef  DEBUG_SCAN_ACTION
            DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "Freeze STC: %lx\n", __dwSTCValue);
#endif  // #ifdef DEBUG_SCAN_ACTION

            UTL_OutputShowTime();

            // Must stop decoder first while
            // [1] 1st enter SCAN mode(SCAN_INIT) or
            // [2] time-out for waiting no SCAN_DONE ack (!=SCAN_END)
            // Otherwise, it may cause Decoder hang easily
            // Since stop servo and parser procedure is put before HAL_RESET_VIDEO
            // And, the bitstream is not sent completely.
            // Notice: can't put before reading STC value
            // Since, the STC value will be reset to zero while STOP command.
            if(__bScan != SCAN_END)
            {
                HAL_PlayCommand(COMMAND_STOP, NULL_0);
            }

            // Stop parser and servo
            // Notice: must put before buffer reset done
            // Otherwise parser will continue to sending data to buffer
            SrcFilter_Stop(__dwSFStreamID);
            HAL_ControlParser(HAL_PARSER_STOP, 0);

            // LLY1.20, freeze STC to waiting next STC
            // since STC is forever freezed by F/W before issue stop command
            DISP_STCFreeze(__dwSTCValue, DISP_WAIT_NEXT_STC);


            // Reset video buffer for new range data sending
            HAL_Reset(HAL_RESET_VIDEO);

            // LLY.100, reset SPST because SPST is discontinue while SCAN command
            // Ming0.68-909, Disable sub-picture on SCF, SCB, STOP mode.
            // Need not to reset sub-picture now.
            //HAL_Reset(HAL_RESET_SPST);

            // Calculate the next jump position.
#ifdef  ENHANCE_CELL_ERROR_CONCEAL
            if (_bCheckNVData != CELL_NV_NONE)  // no available NV data
            {
                __dwVOBUSA++;
                // only can scan jump by sectors
                __bCellAction=VOBU_NEXT;
                //Aron2.78-909p, fix SCFx32 the video display soon when crossing chapter
                goto LABEL_WAIT_SCAN_END;//LABEL_ISSUE_SCAN;

            }
#endif  //#ifdef  ENHANCE_CELL_ERROR_CONCEAL


            if (__bModeCmd==KEY_SCF)
            {
                _bIndex=bFWDI[__bScanLevel-1];
            }
            else  if (__bModeCmd==KEY_SCB) // DVD_101-2Micky, fix scb->fast will hang
            {
                _bIndex=bBWDI[__bScanLevel-1];
            }
            else
            {
                // DVD_101-2Micky, fix scb->fast will hang
                _bIndex=0xff;
            }

            //DVD_050Micky
            // NF-200, non-seamless angle change cell 1->SCF
            // when VOBUSA=2885, the VOBUSRI=0x80000000
            // means the start address is 0.
            // it will cause __dwVOBUSA recursive.
            if (__bModeCmd==KEY_SCF)
            {
                // no more next VOBU
                if ( (__dwVOBUSRI&0x3fffffff)==0x3fffffff )   // bit 31/30 is video flag
                {
                    __bCellAction=VOBU_NEXT;
                    //Aron2.78-909p, fix SCFx32 the video display soon when crossing chapter
                    goto LABEL_WAIT_SCAN_END;//LABEL_ISSUE_SCAN;
                }
            }


            // DVD_101-2Micky, fix scb->fast hang
            // SCB has issued last VOBUSA, and got NV data, but __dwVOBUSRI is not 0x3fffffff???
            // it cause ScanJump will directly use __dwVOBUSRI
            if (_bIndex != 0xff)
            {
    // DVD_103Micky, reduce DSI
#ifdef  REDUCE_DSI

                // Micky2.31, reduce codes(26 bytes)
    //            __dwVOBUSRI = _SearchFWDI((BYTE)_bIndex);
                //Ming0.80, use PCI and DSI directly.
                __dwVOBUSRI = _SearchFWDI(_bIndex);

#ifdef  _DEBUG_DSI
                __dwTemp=
                MAKELONG(MAKEWORD(cDSI.VOBU_SRI[_bIndex*4-1],
                        cDSI.VOBU_SRI[_bIndex*4-1-1]),
                        MAKEWORD(cDSI.VOBU_SRI[_bIndex*4-1-2],
                        cDSI.VOBU_SRI[_bIndex*4-1-3]));
                if (__dwTemp != __dwVOBUSRI)
                {
                    DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\n[DSI_ERROR8]VOBUSRI=%lu", __dwVOBUSRI);
                }
#endif  // #ifdef  _DEBUG_DSI
#else   // #ifdef  REDUCE_DSI

                _bIndex= _bIndex*4-1;
                __dwVOBUSRI=
                MAKELONG(MAKEWORD(cDSI.VOBU_SRI[_bIndex],
                        cDSI.VOBU_SRI[_bIndex-1]),
                        MAKEWORD(cDSI.VOBU_SRI[_bIndex-2],
                        cDSI.VOBU_SRI[_bIndex-3]));
#endif  // #ifdef  REDUCE_DSI

            }

            // DVD_102Micky, fix dinosaur 1/25->scfx8 will hang at 01:09:19
            // the cell 139 only 2 seconds
            // no more next VOBU from bIndex
            if ( (__dwVOBUSRI&0x3fffffff)==0x3fffffff )   // bit 31/30 is video flag
            {
                __bCellAction=VOBU_NEXT;
                goto LABEL_ISSUE_SCAN;
            }

            if (!(__dwVOBUSRI & 0x80000000))   // video exist flag
            {
                // no video data exist in this VOBU
            }

#ifdef  _CELL_INFO
            DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nIFSC=%lu\n", __dwCurrentVOBUSA);
#endif  // #ifdef  _CELL_INFO

            // DVD_099Micky, fix SCF-> play will rewind a little
            // because __bModeCmd already changed to KEY_PLAY(cc.c)
            // but CELL will go SCB's path.(if SCF... eles...)
            // the rule should be when leave SCF/SCB mode,
            // the director should be forward play the next VOBU.
            // __dwVOBUSA record the next incoming VOBU
            // __dwCurrentVOBUSA record the played VOBU
            // (and __dwVOBUSRI is only valid for this VOBU, CurrentVOBUSA)
            /*
            __dwVOBUSA=__dwCurrentVOBUSA;
            if (__bModeCmd==KEY_SCF)
                __dwVOBUSA+=__dwVOBUSRI&0x3fffffff;   // bit 31/30 is video flag
            else
                __dwVOBUSA-=__dwVOBUSRI&0x3fffffff;   // bit 31/30 is video flag
            */
            if (__bModeCmd==KEY_SCF)
            // Micky1.25, fix Dinosaur(Region1, 19572), SCFx2 to 1:45 will hang
            // the __dwVOBUSRI record as 0x80000000,
            // __dwCurrentVOBUSA=0x83de, so it will loop playing from __dwCellFVOBUSA+ 0x83de
            {
                // Only reference __dwVOBUSRI when its va;ue is non-zero.
                // if its value is 0, juts use next VOBU(__dwVOBUSA value)
                if ((__dwVOBUSRI & 0x3fffffff) )
                {
                    __dwVOBUSA=__dwCurrentVOBUSA + (__dwVOBUSRI&0x3fffffff);   // bit 31/30 is video flag
                }
            }
            else if (__bModeCmd==KEY_SCB)
            {
                __dwVOBUSA=__dwCurrentVOBUSA - (__dwVOBUSRI&0x3fffffff);   // bit 31/30 is video flag
            }
            else
            {
                // otherwise, __dwVOBUSA is ready for next VOBU.
            }

            // DVD_102Micky, fix dinosaur 1/25->scfx8 will hang at 01:09:19
            // it will go recursive loop
            // only do recursive check for scb
            if ( __bModeCmd == KEY_SCB )
            {
                // SCB recursive protection V1->V2->V3->IFSC-> V1...
                // on title The Devil's Advocate(TT/CC 01/01, emulator)
                if (__dwVOBUSA==_dwPreScanPosition)
                {
                    DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nRecursive VOBUSA=%lu", __dwVOBUSA);
                    // DVD_102bMicky, fix MI-2, 01/17->SCB recursive
                    // it will play 1x VOBUs then get IFSC, so the backward time need more
    // DVD_103Micky, reduce DSI
#ifdef  REDUCE_DSI
                    _bIndex +=8;
                    if (_bIndex > 42)   // total 42s VOBU SRI
                    {
                        __dwVOBUSRI=0x3fffffff;
                    }
#else   // #ifdef  REDUCE_DSI

                    _bIndex+=4*8;         // must be care if __bIndex too large
                    if (_bIndex > 167)
                    {
                        __dwVOBUSRI=0x3fffffff;
                    }
#endif  // #ifdef  REDUCE_DSI
                    else
                    {
                        __dwVOBUSA=__dwCurrentVOBUSA;
    // DVD_103Micky, reduce DSI
#ifdef  REDUCE_DSI
                        // Micky2.31, reduce codes(26 bytes)
                        // __dwVOBUSRI = _SearchFWDI((BYTE)_bIndex);
                        //Ming0.80, use PCI and DSI directly.
                        __dwVOBUSRI = _SearchFWDI(_bIndex);

#ifdef  _DEBUG_DSI
                        __dwTemp=
                            MAKELONG(MAKEWORD(cDSI.VOBU_SRI[_bIndex*4-1],
                                cDSI.VOBU_SRI[_bIndex*4-1-1]),
                            MAKEWORD(cDSI.VOBU_SRI[_bIndex*4-1-2],
                                cDSI.VOBU_SRI[_bIndex*4-1-3]));
                        if (__dwTemp != __dwVOBUSRI)
                        {
                            DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\n[DSI_ERROR9]VOBUSRI=%lu", __dwVOBUSRI);
                        }
#endif  // #ifdef  _DEBUG_DSI


#else   // #ifdef  REDUCE_DSI
                        __dwVOBUSRI=
                            MAKELONG(MAKEWORD(cDSI.VOBU_SRI[_bIndex],
                                cDSI.VOBU_SRI[_bIndex-1]),
                            MAKEWORD(cDSI.VOBU_SRI[_bIndex-2],
                                cDSI.VOBU_SRI[_bIndex-3]));
#endif  // #ifdef  REDUCE_DSI

                        __dwVOBUSA-=__dwVOBUSRI&0x3fffffff;   // bit 31/30 is video flag
                        // DVD_099Micky, The Devil's Advocate
                        // TT/CC 01/01 will recursive at VOBUSA=0
                        if (__dwVOBUSA==0)
                        {
                            __bCellAction=CELL_LAST_VOBU;
                            goto LABEL_ISSUE_SCAN;
                        }
                    }
                }
            }

            // DVD_102Micky, don't update invalid Scan position
            if (__dwVOBUSA == 0x3ffffff)
            {
                DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nScan error VOBUSA");
            }

            _dwPreScanPosition=__dwVOBUSA;

            if (__bAngleChange)
            {
                __bCellAction=ILVU_END;
            }
            else
            {
                __bCellAction=VOBU_NEXT;
            }

            // LLY2.77, must return FALSE while SCAN_DONE flag is got
            // and wait time-out to issue next SCAN command
            // ie. must Let CELL_Trigger() don't going.
            return FALSE;

        }

        // LLY2.77, must return TRUE while waiting SCAN_DONE flag case
        // ie. must let CELL_Trigger() continue go
        // Otherwise, nobody will send data, and always can't get SCAN_DONE flag
        return TRUE;


//    case    SCAN_STAGE_NEXT_SCAN:
    case    SCAN_END:
        // Wait 500 msec to control SCAN mode frame display period
        // Since the scan mode speed is very fast.
        //while( (OS_GetSysTimer() - __dwScanTime) < COUNT_500_MSEC )
        if( (OS_GetSysTimer() - __dwScanTime) < COUNT_500_MSEC )
        {
            //OS_YieldThread();
            return FALSE;
        }

        // LLY2.38, go issue scan command directly,
        // ie. don't wait time-out while cell action change procedure
        // Otherwise, scan stage will stay @ wait time-out but cell trigger will continue go.
LABEL_ISSUE_SCAN:
        // Issue next SCAN CMD, and set SCAN status as SCAN_GO
        // LLY2.01, call HAL_PlayCommand() instead of COMDEC_Command(). (same as other title SCAN mode)
        //COMDEC_Command(MODE_SCAN, 0);
        HAL_PlayCommand(COMMAND_SCAN, 0);
        __bScan=SCAN_GO;

        // Keep issue SCAN CMD time
        __dwTimeRef=OS_GetSysTimer();

#ifdef  DEBUG_SCAN_ACTION
        DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "Issue SCAN again\n");
#endif  // #ifdef DEBUG_SCAN_ACTION

        return TRUE;
    }

#endif  // #ifndef NO_DVD
    return TRUE;

}


void _CellVOBUSearch()
{
#ifndef NO_DVD

    __dwTimeNow=CELL_QueryTime();
#ifdef _CELL_INFO
    DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nCurrentTime=%lu\n", __dwTimeNow);
#endif
    // Desired time < current time : Do backward search.
    if (__dwTimeNow > _dwSearchTime)
    {
        // second based
        __dwTemp=__dwTimeNow-_dwSearchTime;
        if (__dwTemp >=120)
        {
            // jump 120 seconds, BWDI240, index 41
            _bIndex=41;  // jump 120 seconds
        }
        else if (__dwTemp >=60)
        {
            // jump 60 seconds, BWDI120,index 40
            _bIndex=40;
        }
        else if (__dwTemp >=30)
        {
            // jump 30 seconds, BWDI60, index 39
            _bIndex=39;
        }
        else if (__dwTemp >= 10)
        {
            // jump 10 seconds, BWDI20, index 38
            _bIndex=38;
        }
        else if (__dwTemp >=7)
        {
            // jump 7 seconds, BWDI14, index 36
            _bIndex=36;
        }
        else
        {
            // Others
            _bIndex=(BYTE)((__dwTemp*2)+22);
        }
        __dwTemp=1;
    }
    // Desired time > current time : Do forward search
    else if (__dwTimeNow < _dwSearchTime)
    {
        // second based
        __dwTemp=_dwSearchTime-__dwTimeNow;
        if (__dwTemp >=120)
        {
            // jump 120 seconds, FWDI240, index 2
            _bIndex=2;  // jump 120 seconds
        }
        else if (__dwTemp >= 60)
        {
            // jump 60 seconds, FWDI120,index 3
            _bIndex=3;
        }
        else if (__dwTemp >= 30)
        {
            // jump 30 seconds, FWDI60, index 4
            _bIndex=4;
        }
        else if (__dwTemp >= 10)
        {
            // jump 10 seconds, FWDI20, index 5
            _bIndex=5;
        }
        else if (__dwTemp >=7)
        {
            // LLY2.32, the index is wrong since it must do forward search
            // jump 7 seconds, FWDI14 (7 ~ 7.4 sec), index 7
            //_bIndex=14;
            _bIndex=7;
        }
        else
        {
            // Others.
            // Notice: FWDI Next (0 ~ 0.4 sec); FWDI1 (0.5 ~ 0.9 sec); FWDI2 (1 ~ 1.4sec)
            //         So, if jump 1sec, must searh FWDI2, index 19
            _bIndex=21-(BYTE)((__dwTemp*2));
            //_bIndex=20-(BYTE)((__dwTemp*2));
        }
        __dwTemp=0;
    }
    else
    {
        // it takes about 1 plus second to serach from 0 to 800 seconds
        // DVD_171-2Micky, re-define the parameter for _bEnableTimeSearch
        // the specified time is reached.
        _bEnableTimeSearch=CELL_TIMESEARCH_NONE;
        return;
    }
    // Micky2.31, reduce codes.
    __dwVOBUSA=__dwCurrentVOBUSA;

    // _SearchFWDI will use __dwTemp, must referenc it first.
    if (__dwTemp)   // need backward search
    {
        __dwVOBUSRI = _SearchFWDI(_bIndex);

        // LLY2.31, porting Micky's code for error protection if find a invalid SRI value
        // Micky0720 begin
		// find the nearest no 0x3ffffff entry
		if ( (__dwVOBUSRI & 0x3ffffff) == 0x3ffffff )
		{
			int k;
			for (k=41; k>=23; k--)
			{
				__dwVOBUSRI = _SearchFWDI(k);
				if ( (  __dwVOBUSRI & 0x3ffffff) != 0x3ffffff )
				{
					_bIndex = k;
                    //printf(", new Index = %hd", _bIndex);
					__dwVOBUSRI = _SearchFWDI((BYTE)_bIndex);
					break;
				}
			}
		}
        // Micky0720 end

        __dwVOBUSA-=__dwVOBUSRI&0x3fffffff;   // bit 31/30 is video flag
    }
    else
    {
        __dwVOBUSRI = _SearchFWDI(_bIndex);

        // LLY2.31, porting Micky's code for error protection if find a invalid SRI value
        // Micky0720 begin
		// find the nearest no 0x3ffffff entry
		if ( (__dwVOBUSRI & 0x3ffffff) == 0x3ffffff )
		{
			int k;
			for (k=_bIndex; k<=20; k++)
			{
				__dwVOBUSRI = _SearchFWDI(k);
				if ( (  __dwVOBUSRI & 0x3ffffff) != 0x3ffffff )
				{
					_bIndex = k;
					__dwVOBUSRI = _SearchFWDI((BYTE)_bIndex);
					break;
				}
			}
		}
        // Micky0720 end

        __dwVOBUSA+=__dwVOBUSRI&0x3fffffff;   // bit 31/30 is video flag
    }

// DVD_103Micky, reduce DSI
#ifdef  REDUCE_DSI

#ifdef  _DEBUG_DSI
#ifdef  SUPPORT_PRINTF
    // !!! __dwTemp will be used later as direction control, can't destroy the value!!!
    _bIndex=(_bIndex*4)-1;       // VOBU start address
    if (MAKELONG(MAKEWORD(cDSI.VOBU_SRI[_bIndex],
            cDSI.VOBU_SRI[_bIndex-1]),
            MAKEWORD(cDSI.VOBU_SRI[_bIndex-2],
            cDSI.VOBU_SRI[_bIndex-3])) != __dwVOBUSRI)
    {
        DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\n[DSI_ERROR11]VOBUSRI1=%lu", __dwVOBUSRI);
    }
#endif
#endif
#else
    _bIndex=(_bIndex*4)-1;       // VOBU start address
    __dwVOBUSRI=
    MAKELONG(MAKEWORD(cDSI.VOBU_SRI[_bIndex],
            cDSI.VOBU_SRI[_bIndex-1]),
            MAKEWORD(cDSI.VOBU_SRI[_bIndex-2],
            cDSI.VOBU_SRI[_bIndex-3]));
#endif

    // Micky2.31, reduce codes
    // move above
    /*
    __dwVOBUSA=__dwCurrentVOBUSA;
    if (__dwTemp)   // need backward search
        __dwVOBUSA-=__dwVOBUSRI&0x3fffffff;   // bit 31/30 is video flag
    else
        __dwVOBUSA+=__dwVOBUSRI&0x3fffffff;   // bit 31/30 is video flag
    */

#endif  //#ifndef NO_DVD
}


DWORD   CELL_QueryTime(void)
{
#ifndef NO_DVD
    DWORD    dwCellTime;  // seconds


    //Ming0.80, use PCI and DSI directly.
    dwCellTime =  COMUTL_DecimaltoBCD (_pPCI->PCI_GI.C_ELTM[2]&0x0f);
    dwCellTime += COMUTL_DecimaltoBCD ((_pPCI->PCI_GI.C_ELTM[2]&0xf0)>>4)*10L;
    dwCellTime += COMUTL_DecimaltoBCD (_pPCI->PCI_GI.C_ELTM[1]&0x0f)*60L;
    dwCellTime += COMUTL_DecimaltoBCD ((_pPCI->PCI_GI.C_ELTM[1]&0xf0)>>4)*600L;
    dwCellTime += COMUTL_DecimaltoBCD (_pPCI->PCI_GI.C_ELTM[0]&0x0f) * 3600L;
    dwCellTime += COMUTL_DecimaltoBCD ((_pPCI->PCI_GI.C_ELTM[0]&0xf0)>>4) * 36000L;

    if ( (__bCellState == CELL_SKIP_VOBU) || (__bCellState == CELL_LINEAR) )
    // Micky0.87b, protect __bNVRecover=0;
    // it't not necessary when no skip was done.
    // in MS-VC, it will use last element of array when out of range.
    if (_bNVRecover)
        dwCellTime += _bSkipTime[(_bNVRecover > CELL_MAX_SKIP_GAP? CELL_MAX_SKIP_GAP : _bNVRecover) -1];

    return (dwCellTime);
#endif  // #ifndef NO_DVD
    return (0);
}


// Comment it, since nobody call it now.
// Need double check if it's necesary to support
#if 0
void CELL_Recover(void)
{
#ifndef NO_DVD
    //Aron1.15-909, it is not uesd by others, comment it!
    //__wNextILVUSZ=0;

    __bAngleChange=FALSE;

    _bCheckNVData=CELL_NV_NONE;
    _bNVRecover=0;

#ifdef  ENHANCE_CELL_ERROR_CONCEAL
    // DVD_155Micky, always set cell as linear after reset
    if (1)
    {
        DWORD   SKIP_GAP;
        // Micky0.87, for multi-angle, use last NV sector for skip. begin
        // to make sure after reset recover, still play last angle number
        if (__bAGL_Ns && __bInterleaved)
        {
            // skip 1s.(FWDI 2, the 19th entry) from current hang postion
//            __dwTemp = _SearchFWDI((BYTE)19);
            //Ming0.80, use PCI and DSI directly.
            __dwTemp = _SearchFWDI(19);
            __dwTemp &= 0x3fffffff;
            if (__dwTemp==0x3fffffff)
            {
                // Micky1.24, correct flow should be CELL_LAST_VOBU
                //__bCellAction = CELL_END;
                __bCellAction = CELL_LAST_VOBU;
                return;
            }

            __dwVOBUSA = __dwCurrentVOBUSA + __dwTemp;
            // suppose it's a valid NV sector within same angle.
            // if it's not NV sector, the flow will enter SkipGap again.
            __bCellAction = VOBU_START;
            return;
            // using the method, may receive the other angle's NV sector
//            __dwVOBUStart = __dwCellFVOBUSA + __dwVOBUSA;
        }
        else
        // Micky0.87, for multi-angle, use last NV sector for skip. end
        {
        // each time jump 1/10 of whole cell.
        SKIP_GAP=(__dwCellLVOBUEA - __dwCellFVOBUSA)/10;
        if ((__dwVOBUStart + SKIP_GAP) < (__dwCellLVOBUEA))
            __dwVOBUStart+=SKIP_GAP;
        else
        {
            // Micky1.24, correct flow should be CELL_LAST_VOBU
            //__bCellAction = CELL_END;
            __bCellAction = CELL_LAST_VOBU;
            return;
        }
        }
        __bCellState = CELL_LINEAR;

        // LLY2.32, ask parser to stop while finding NV sector
        // Notice: only enable it while linear play mode
        //         and must clear it while NV re-find case.
        PARSER_ActionFilter(0, PARSER_ENABLE_NV_PAUSE, TRUE);


        // Micky1.21, clear time search when linear mode
        // to avoid linear->re-found-> will play backward time.
        _bEnableTimeSearch=CELL_TIMESEARCH_NONE;

        __dwVOBUEnd = __dwCellLVOBUEA;
#ifdef  SUPPORT_PRINTF
        DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\n[Monitor]Linear %lu-%lu", __dwVOBUStart, __dwVOBUEnd);
#endif  // #ifdef  SUPPORT_PRINTF

        // TCC278
        __dwTimeBegin = __dwVOBUStart;
        __dwTimeEnd = __dwVOBUEnd ;
        // LLY2.35, give start and end time for UTL_PlayFromTime() since the API is updated
        UTL_PlayFromTime (__dwVOBUStart, __dwTimeEnd) ;
        //SERVO_ReadSectors(__dwVOBUStart, __dwVOBUEnd);
        __bCellAction=VOBU_PLAYING;
        // Micky0.66-909, clear NV flag
        PARSER_QueryEvent( 0, PARSER_EVENT_NV_PACK, TRUE);
		// Micky0.67-909, the flow is for bitstream sent complete and control are same thread
		// for 909, better control parse to stop for each NV-> then go VOBU_END flow directly.
		// wait for test.
		PARSER_ActionFilter(0, PARSER_ENABLE_NV_PAUSE, TRUE);

        // DVD_275aMicky, don't clear time search mode
        // as when repeat A-B fail, if clear it, time search will from cell begin
        // but the search will still fail-> reset recover-> it will play from the time close to cell begin
        // instead of real A-B time.
/*
        // DVD_171-2Micky, re-define the parameter for _bEnableTimeSearch
        _bEnableTimeSearch=CELL_TIMESEARCH_NONE;
*/
    }
#endif  // #ifdef  ENHANCE_CELL_ERROR_CONCEAL
#endif  // #ifndef NO_DVD
}
#endif  // #if 0

//DVD_039-1
BYTE    _CheckForceActive(void)
{
#ifndef NO_DVD
    // !!!!!need check!!!!!!!!
    // must check highlight time out/selection time out,
    // and execute ForceActiveBTN
    if (__bForceActiveBTNN)
    {
        if ( __dwBTNSelEndTime!=0xffffffff )
        {
            // check the STC value reach the selection end time
//DVD_039-1
// check force active button at cell end
            HAL_ReadInfo(HAL_INFO_STC, &__dwTemp);
            // early doing the action by 0.25 seconds.
            // or highlight perion will end.
            // Micky2.81, don't check time for non-NPF.
//            if ((__dwTemp + 23000L)< __dwBTNSelEndTime)
            // Micky1.24, fix Panasasonic TT/CC 8/1-> slow-> the multi-story selection will skip play.
            // as it will execute the force active button at the beginning.
            /*
            if ( (__bModeCmd == KEY_PLAY) &&
                 (__dwTemp + 23000L)< __dwBTNSelEndTime )
            */
            if ( (__dwTemp + 23000L)< __dwBTNSelEndTime )
            {
                if ( (__bModeCmd == KEY_SCF) || (__bModeCmd == KEY_SCB) )
                {
                }
                else
                    return FALSE;
            }
            else    //reach the selection end time
            {
                __dwBTNSelEndTime=0;
                //DVD_050Micky
                // Fix Panassonic title auto play
                // doing later
            }
        }
        else    // must wait until CELL still end, then
        {
        //DVD_041-1
        // must wait still time ending then force active button
            //DVD_041-2
            // can't force active, or user can't do selection
            // [Die Hard]
            // 1. Title->Still=1, SelEndTime=0xffffffff
            // 2. Menu->Still=120, SelEndTime=0xffffffff
            // 3. Menu->Jump to a scene->Still=0xff, SelEndTime=0xffffffff
            // on DieHard Menu->Jump to a scene
            if (__bCellAction!=CELL_CHECK_FORCEACTIVE)
                return FALSE;
            // else must change button to force active button number
            // doing later
        }
    }
    //DVD_050Micky
    // no force active button
    else
        return FALSE;

    // only selection end time or still end will come here
    // must change button to force active button number
    // execute the ForceActiveBTN
    if (__bForceActiveBTNN!=0x3f)
    {
        // Force Active BTN is not current selection button
        // must select the BTN first
        // then active the button
        if (__bNowBTNNumber!=__bForceActiveBTNN)
        {
            // need select the button first
            __bNowBTNNumber=__bForceActiveBTNN;
        }
    }
    else
    {
    // 0x3f, execute the current select button
    }

    // clear bits 10-15
    __wSPRMs [8]&=0x03ff;
    __wSPRMs [8]|=(WORD)(__bNowBTNNumber) << 10;

    //DVD_039-1
    // only allow to call HAL_ControlHighlight
    // as CELL_ButtonControl(xx, HAL_HLI_ACTION_ACTIVE/SELECT) are
    // allowed only under User button.
    HAL_ControlHighlight(HAL_HLI_ACTION_ACTIVE, __bNowBTNNumber+__bGroupOffset);

    // then active the button
    _ActiveButton();
//DVD_039-1
// change the state to execute the button command
    __bForceActiveBTNN=0;

#endif  // #ifndef NO_DVD
    return TRUE;//__bCellAction;
}


BYTE    CELL_QueryStatus(BYTE bQuery)
{
#ifndef NO_DVD
    switch(bQuery)
    {
        // DVD_100Micky, add Cell status(Cell Still/VOBU still)
        case    CELL_IS_STILL:
            // DVD_155Micky, for forever cell still
                if (__bStillTime)// || __bVOBUStill)
                    return TRUE;
                else
                    return FALSE;
                break;
        // DVD_102Micky, support PAUSE/PLAY to release VOBU still
        case    CELL_VOBU_STILL_ON:
        case    CELL_VOBU_STILL_OFF:
                // DVD_161Micky, only __bVOBUStill is true for the cell
                // then the VOBU_STILL can exist.
                if (__bVOBUStill)
                {
                    if (__bCellAction == VOBU_STILL)
                    {
                        if (bQuery==CELL_VOBU_STILL_OFF)    // release VOBU still
                        // Micky0.95, Fix Video hang a moment then continue the playback after last time KEY_PLAY pressing when VOBU still
                        // now VOBU still is PAUSE, must release PAUSE mode.
                        {
                            __bCellAction=VOBU_NEXT;
                            // Micky0.96, free go STC
                            DISP_STCFreeze(0x0, DISP_UNFREEZE_STC);
                            // LLY1.06, Clear the flag while unfreeze the STC
                            _bForceFreezeSTC=FALSE;
                          //DISP_NewSTC(__dwVOBU_E_PTM, TRUE);
                        }
                        return TRUE;
                    }
                }
                return FALSE;
                break;

        // DVD_101-2Micky, add button number select check
        case    CELL_BUTTON_SELECT:
                // DVD_171-4Micky, fix KEY_PLAY_PAUSE won't act as KEY_PAUSE
                // after NV_Action(ACTION_ACTIVE_CHECK) in cc.c
                // as 1.71 won't clear __bNowBTNNumber.
                // so must check button state first.
                if (_bButtonState == CELL_BUTTON_SELECTION)
                {
                    if (__bNowBTNNumber)
                        return TRUE;
                }
                return FALSE;
                break;
        // DVD_101-2Micky, add button number check
        case    CELL_BUTTON_NUMBER:
                if (__bSELBTN_Ns)
                    return TRUE;
                else
                    return FALSE;
                break;
// DVD_273.2Micky, add query for non-NOP command
        case    CELL_SCAN_BTN_COMMAND:
                return _ScanButtonCommands();
                break;
    }
#endif  // #ifndef NO_DVD
    return FALSE;
}


// DVD_161Micky, add a function to update cell range
//  *********************************************************************
//  Function    :   _UpdateCellRange
//  Description :   This function will accord to __pbi_CELL, update cell range,
//  Arguments   :   None
//  Return      :   None
//  Used when   :   After CELL doing angle change(new VOBUSA is decided),
//              :   will need update cell range.
//  Side Effect :
//  *********************************************************************
void    _UpdateCellInfo(void)
{
#ifndef NO_DVD
// DVD_161aMicky, as now repeat AB method will record the TimeA/B based
// on current __dwCellFVOBUSA, so can't update __dwCellFVOBUSA now.
// DVD_170Micky, repeat ab is not done by cell since 1.62.
// but still can't open the update for FVOBUSA
// as angle change now still reference initial play angle's FVOBUSA
// only can be opened after angle change reference new angle cell VOBUSA.
/*
    // first sector address for first VOBU of the CELL
    __dwCellFVOBUSA= MAKELONG(MAKEWORD((__pbi_CELL).C_FVOBU_SA[3],(__pbi_CELL).C_FVOBU_SA[2]),
                     MAKEWORD((__pbi_CELL).C_FVOBU_SA[1],(__pbi_CELL).C_FVOBU_SA[0]));
    // sector address for first ILVU end address of the CELL
    __dwCellFILVUEA= MAKELONG(MAKEWORD((__pbi_CELL).C_FILVU_EA[3],(__pbi_CELL).C_FILVU_EA[2]),
                     MAKEWORD((__pbi_CELL).C_FILVU_EA[1],(__pbi_CELL).C_FILVU_EA[0]));
    __dwCellFVOBUSA+= _dwFirst_VOBS;
    __dwCellFILVUEA+= _dwFirst_VOBS;
*/
    // sector address for last VOBU of the CELL
    __dwCellLVOBUSA= (__pbi_CELL).C_LVOBU_SA;
#ifdef  USE_LITTLE_ENDIAN
    COMUTL_SwapDWORD ( &__dwCellLVOBUSA );
#endif  // #ifdef  USE_LITTLE_ENDIAN

    // last sector address for last VOBU of the CELL
    __dwCellLVOBUEA= __pbi_CELL.C_LVOBU_EA;
#ifdef  USE_LITTLE_ENDIAN
    COMUTL_SwapDWORD ( &__dwCellLVOBUEA );
#endif  // #ifdef  USE_LITTLE_ENDIAN

    __dwCellLVOBUSA+= _dwFirst_VOBS;
    __dwCellLVOBUEA+= _dwFirst_VOBS;
#endif  // #ifndef NO_DVD
}


// DVD_273.2Micky, add special function to execute non-NOP command
//  *********************************************************************
//  Function    :   _ScanButtonCommands
//  Description :   This is a special user function, to search within button
//              :   commands for the one and only non-NOP command, and execute.
//  Arguments   :   None.
//  Return      :   TRUE, a non NOP command is executed
//              :   FALSE, do nothing.
//  Used when   :   Some titles may need user input specific button number,
//              :   then can play forward.
//  Side Effect :
//  *********************************************************************
BYTE    _ScanButtonCommands(void)
{
#ifndef NO_DVD
    int i;
    if ( !(__wDiscType & BOOK_DVD) )
        return FALSE;
    // only allowed when playing mode
    if ( !__btPlaying && !__btPause)
        return FALSE;

    _bIndex=0;  // the button number to be executed.
    for (i=0; i< __bBTN_Ns; i++)
    {

        // Micky2.31, reduce codes, add API _UpdateBTNInfo()
        //Ming0.80, use PCI and DSI directly.
        // Do not need _UpdateBTNInfo().
        //_UpdateBTNInfo((BYTE)(i+1));
        _pBTNInfo = (PCI_BTNIT *)&_pPCI->HLI.BTNIT[i+1-1];

        if ( ((*_pBTNInfo).BTN_CMD[0]==0) && ((*_pBTNInfo).BTN_CMD[0]==0) )
        {
            // Operation code = 0x0000, means NOP.
        }
        else
        {
            // non-NOP command
            if (!_bIndex)
            {
                // record 1st non NOP command's button number.
                _bIndex = i+1;
            }
            else
            {
                // stop command scan, as more than one non NOP commands.
                // and don't execute the command.
                _bIndex = 0;
                break;
            }
        }
    }

    if (_bIndex)    // only one non NOP command exist.
    {
        __bNowBTNNumber = _bIndex;
        _ActiveButton();
        _NV_ExecuteHighLight();
        return TRUE;
    }

#endif  // #ifndef NO_DVD

    return FALSE;

}


#ifdef CELL_FORCE_LINEAR_PLAY_TEST
void _SwitchLinearPlayAndNVPlay(BYTE bForce2NVPlay)
{
    if ((_bLinearNPFFlags & CELL_LINEAR_NPF_RUN) &&
        (__bCellAction == VOBU_PLAYING))
    {
        if(bForce2NVPlay ||
           !(_bLinearNPFFlags & CELL_LINEAR_NPF_OK) ||
           __bInterleaved ||
           (_bEnableTimeSearch != CELL_TIMESEARCH_NONE))
             // Do not support SCF and SCB in CELL linear playing mode.
        {
            PARSER_ActionFilter(0, PARSER_ENABLE_NV_PAUSE, FALSE);
            __bCellState = CELL_NORMAL;
            _bLinearNPFFlags &= (~CELL_LINEAR_NPF_RUN);
        }
    }
}

void CELL_ChangeNVPlayMode(BYTE bForceNVPlay)
{
    if(__wDiscType & BOOK_DVD)
    {
        if ((_bLinearNPFFlags & CELL_LINEAR_NPF_RUN) &&
            (__bCellAction == VOBU_PLAYING) &&
            (bForceNVPlay ||
             !(_bLinearNPFFlags & CELL_LINEAR_NPF_OK) ||
             __bInterleaved ||
             (_bEnableTimeSearch != CELL_TIMESEARCH_NONE) ||
             // Do not support SCF and SCB in CELL linear playing mode.
             ((__bModeCmd == KEY_SCF) ||
              (__bModeCmd == KEY_SCB))))
        {
            _SwitchLinearPlayAndNVPlay(TRUE);
            __bCellState = CELL_NORMAL;
            _bLinearNPFFlags &= (~CELL_LINEAR_NPF_RUN);
        }
    }
}
#endif  // CELL_FORCE_LINEAR_PLAY_TEST


// Micky0.67-909
#if defined(SUPPORT_PRINTF) || defined(SERIAL_DEBUG)
void CELL_Debug(void)
{
#ifndef NO_DVD
    DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\n------- CELL Status--------------,__dwVOBUStart-__dwVOBUEnd=0x%lx-0x%lx;", __dwVOBUStart, __dwVOBUEnd);   // ** TCH1.07;
    DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\n_bCheckNVData=0x%hx; __bCellAction = 0x%hx,  __bCellState=0x%hx",_bCheckNVData, __bCellAction, __bCellState);
    DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nCell Range=h%lx-h%lx,VOBUSA=h%lx,__dw1stSCR=h%lx", __dwCellFVOBUSA, __dwCellLVOBUEA, __dwVOBUSA, __dw1stSCR);
// ** TCH1.07;     DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\n__dwVOBUStart-__dwVOBUEnd=0x%lx-0x%lx; ", __dwVOBUStart, __dwVOBUEnd);
    DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "_bNVRecover=0x%hx; VOBUStill=%hx, StillTime=%hx;",_bNVRecover, __bVOBUStill, __bStillTime );    // ** TCH1.07;
#endif  // #ifndef NO_DVD
}
#endif	//#if defined(SUPPORT_PRINTF) || defined(SERIAL_DEBUG)


// Ming0.68-909, Must wait for NV to update the SCR.
//               Add the function _WaitParserEventNV for this purpose.
//**********************************************************************
//  Function    : _WaitParserEventNV
//  Description : Wait for Parser to complete the command in dwTime time.
//  Parameters  : dwTime: wait time.
//  return      : NonZero-> Parser complete the command.
//                Zero -> Cannot wait for parser to complete it.
//**********************************************************************
DWORD   _WaitParserEventNV(DWORD dwTime)
{
#ifndef NO_DVD
    DWORD dwTimer, dwRet=0;

    dwTimer=OS_GetSysTimer();
    while( (OS_GetSysTimer() - dwTimer) < dwTime)
    {
        dwRet=PARSER_QueryEvent( 0, PARSER_EVENT_NV_PACK, FALSE );

        // Parser complete the command.
        if(dwRet)
        {
            break;
        }

        // release the CPU
        OS_YieldThread();
    }

#ifdef  DUMP_CELL_INFO
    if(!dwRet)
    {
        DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "Cannot wait for the NV!\n");
    }
#endif  // #ifdef  DUMP_CELL_INFO
    if(!dwRet)
    {
        // Cannot get the NV pack. Stop parser & source filter
        SrcFilter_Stop(__dwSFStreamID);
        HAL_ControlParser(HAL_PARSER_STOP, 0);
    }
    return(dwRet);
#endif  // #ifndef NO_DVD
    return (FALSE);
}


// Micky1.05 begin
#ifdef  CHECK_VOBU_E_PTM
BYTE    _Decide_VOBU_Control(void)
{
#ifndef NO_DVD
    if (__bModeCmd != KEY_PLAY)
        return FALSE;

    // do VOBU control when
    // (1)Motion A/V with highlight (to avoid the NV info overwrite, Matrix(root menu highlight))
    // (2)Still picture without audio(to control the speed of bitstream sending, TDL-002(title 6))
    // (3)Still picture w/ audio(for multi-audio switching, LVP 08.01( title(11) )

    // check the variable direcltly instead of __blHLI_Status, as it may not be on yet after current VOBU sent.
    if (__bBTN_Ns)
        return TRUE;
/*
    HAL_ReadInfo(HAL_INFO_HLI_STATUS, &__dwTemp);
    DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\nHL status=%lu", __dwTemp);
    // must do VOBU control when has highlight
    if (__dwTemp)
    {
        return TRUE;
    }
*/

    HAL_ReadInfo(HAL_INFO_STILL, &__dwTemp);
    if (__dwTemp)
    {
//        return TRUE;


        HAL_ReadInfo (HAL_INFO_AUDIO_REMAIN, &__dwTemp);
        if (__dwTemp)
        {
            return FALSE;
        }
        else
        {
            return TRUE;    // means still picture w/o audio stream
        }


    }


    // Micky1.05, using VOBUEA=0 usually is for still checking
    // ritek 4/1-> key_next-> has 5 VOBUs, but sequence end code is set after 5th VOBU
    // so the checking for still will fail at this case.
    if (__dwVOBUEA==0)
    {
        //DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "__dwVOBUEA=0 \n");
        return TRUE;
    }

    //Aron1.10a, add to prevent DVD "After Tomorrow" TT/CC 2/1 Fox Logo ¼½¤£§¹
    //The cell command in 2/1 will do NV_LINK_TAILPGC
    //when meet cell command, we must do VOBU control to confirm the consumption of
    //Audio and Video
    if ( __pbi_CELL. C_CAT [3] )
        return TRUE;

#endif  // #ifndef NO_DVD
    return FALSE;
}
#endif  //#ifdef  CHECK_VOBU_E_PTM
// Micky1.05 end

//  *******************************************************************************
//  Function    :   _SearchFWDI
//  Description :   Get FWDI/BWDI value from VOBU_SRI table
//  Arguments   :   bIndex, the desired entry index, from '1'
//  Return      :   The corresponding VOBU_SRI value
//  *******************************************************************************
DWORD   _SearchFWDI(BYTE bIndex)
{
    DWORD   dwData;
    dwData = COMUTL_ReadBufferDWORD ((char *)&(_pDSI->VOBU_SRI[bIndex-1]), 0);
    return dwData;
}


// LLY2.32, porting Micky's code for using time map table
// Micky07312006 begin, for TMAP
#ifdef	SUPPORT_TMAP_SEARCH
BOOL SearchTMAPTime()
{
	extern	DWORD	_dwFirst_VOBS;
	DWORD	MAP_EN_Ns;
	DWORD	MAP_ENA;
	WORD	i;
	extern BYTE	__bTMU;
	if (__bInterleaved)
	{
		return FALSE;
	}
	// _dwSearchTime is cell relative time
	if (__bTMU == 0)
	{
		// no TMAP, use VOBU search directly
		return FALSE;
	}
	if ((_dwSearchTime + __wTimeCellBegin) < __bTMU)
	{
		// means the time is before firt __bTMU.(if __bTMU=5, then the time 0~4 is the case)
		// use VOBU search directly
		return FALSE;
	}

	_DVD_LoadFromDRAM(VTS_TMAP,0 );
	MAP_EN_Ns = _ReadBufferWORD(_cCache, 2);

	i = ((_dwSearchTime+__wTimeCellBegin)-__bTMU)/ __bTMU;

	if (i > SIZE_VTS_TMAP/4)
	{
		// out of the max. entry.
		return FALSE;
	}
	if (i > MAP_EN_Ns)
	{
		i= MAP_EN_Ns;
	}

	_DVD_LoadFromDRAM(MAP_ENT, i);
	MAP_ENA = _ReadBufferDWORD(_cCache, 0);
	MAP_ENA &= 0x7fffffff;

//	printf("\nTMAP sector = %lx", _dwFirst_VOBS + MAP_ENA);
	// The case that 303 is 2nd chapter, __bTMU=5(300,301,302,"303",304)
	// the time 303s is loated at previous cell's last __bTMU
	// so can't use the cell time to do the search(cell time will be 300,301,302, 0,1)
	if ((_dwFirst_VOBS + MAP_ENA) < __dwCellFVOBUSA )
	{
		//use VOBU search
		return FALSE;
	}
	__dwVOBUSA = _dwFirst_VOBS + MAP_ENA - __dwCellFVOBUSA;
	__dwCurrentVOBUSA = __dwVOBUSA;

	if ((_dwSearchTime+__wTimeCellBegin) > ((i+1)*__bTMU))
	{
		// The time accurate time is not reached
		// must use VOBU search later
		__bCellAction = VOBU_START;
	}
	else
	{
		_dwSearchTime = 0xffffffff;
		__bCellAction = VOBU_END;
	}
	__bCellState = CELL_NORMAL;
	_bUpdateSCR = TRUE;	// must re-correct SCR
	return TRUE;
}
#endif	//#ifdef	SUPPORT_TMAP_SEARCH
// Micky07312006 end ...


// LLY2.32, porting Micky's code to fix some DVD tile root menu can't play end issue
// for Harry Potter & Alexander root menu can't play end--begin
void	CELL_LinearPlay(void)
{
#ifndef NO_DVD
    __bCellState = CELL_LINEAR;

    // LLY2.32, ask parser to stop while finding NV sector
    // Notice: only enable it while linear play mode
    //         and must clear it while NV re-find case.
    PARSER_ActionFilter(0, PARSER_ENABLE_NV_PAUSE, TRUE);

    // Micky1.21, clear time search when linear mode
    // to avoid linear->re-found-> will play backward time.
    _bEnableTimeSearch=CELL_TIMESEARCH_NONE;

    _bCheckNVData=CELL_NV_NONE;
    __dwVOBUStart=__dwCellFVOBUSA + __dwVOBUSA;
    __dwVOBUEnd=__dwCellLVOBUEA;

    __dwTimeBegin = __dwVOBUStart;
    __dwTimeEnd = __dwVOBUEnd ;
    // LLY2.35, give start and end time for UTL_PlayFromTime() since the API is updated
    UTL_PlayFromTime (__dwVOBUStart, __dwTimeEnd) ;
    __dwTimeNow = __dwVOBUStart;

#ifdef  DUMP_CELL_INFO
    DBG_Printf(DBG_THREAD_CHEERDVD, DBG_INFO_PRINTF, "\n[4]Linear %lu-%lu", __dwVOBUStart, __dwVOBUEnd);
#endif  //#ifdef  DUMP_CELL_INFO

#endif  // #ifndef NO_DVD
}
// for Harry Potter & Alexander root menu can't play end--end


DWORD   CELL_GetCellBeginTime(void)
{
#ifndef NO_DVD
    DWORD   dwTemp;
    HAL_ReadInfo(HAL_INFO_NEW_STC_VALID, &dwTemp);

    if(!dwTemp)
    {
//        printf("Old \n");
        return __wPreTimeCellBegin;
    }
    else
#endif
    {
        return __wTimeCellBegin;
    }
}
